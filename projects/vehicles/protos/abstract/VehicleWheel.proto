#VRML_SIM R2022a utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# documentation url: https://www.cyberbotics.com/doc/automobile/vehiclewheel
# Generic model of a vehicle wheel implemented at the Solid-node level.
# The dimensions of the wheel can be set with the parmameters 'thickness' and 'tireRadius'.
# The quality of the cylinder approximation can be set with the parameter 'subdivision'.
# The subdivision and size of the round edges of the tire can be set with the parameters 'curvatureFactor' and 'edgeSubdivision'.
# The size, shape and position of the rim can be set with the parameters 'rimRadius' 'rimBeamNumber' 'rimBeamWidth' 'rimBeamThickness' 'rimBeamOffset'.
# Finally the size of the central part of the rim can be set with the parameters 'centralInnerRadius' and 'centralOuterRadius'.
# This model was sponsored by the CTI project RO2IVSim (http://transport.epfl.ch/simulator-for-mobile-robots-and-intelligent-vehicles).
# template language: javascript

PROTO VehicleWheel [
  field SFString   name               "vehicle wheel"
  field SFFloat    thickness          0.3
  field SFFloat    tireRadius         0.4
  field SFInt32    subdivision        36
  field SFFloat    curvatureFactor    0.35
  field SFInt32    edgeSubdivision    3
  field SFFloat    rimRadius          0.28
  field SFInt32    rimBeamNumber      5
  field SFFloat    rimBeamWidth       0.1
  field SFFloat    centralInnerRadius 0.09
  field SFFloat    centralOuterRadius 0.13
  field SFFloat    rimBeamThickness   0.2
  field SFFloat    rimBeamOffset      0.03
  field SFString   contactMaterial    "default"
  field SFNode     tireAppearance     GenericTireAppearance {}
  field SFNode     rimAppearance      PBRAppearance { roughness 0.4 }
  field SFNode     physics            Physics {}
  field SFBool     boundingObject     TRUE
  field MFNode     logoSlot           []
  field SFBool     wheelSide          FALSE                            #TRUE for wheels on the left side of the vehicle, FALSE otherwise.
]
{
  %<
    import * as wbgeometry from 'wbgeometry.js';

    // parameter checking
    let subdivision = fields.subdivision.value;
    if (subdivision > 200)
      console.info('High value for \'subdivision\'. This can slow down the simulation.');
    else if (subdivision <= 8) {
      subdivision = 8;
      console.error('\'subdivision\' must be greater or equal to 8. Value reset to ' + subdivision + '.');
    }

    let edgeSubdivision = fields.edgeSubdivision.value;
    if (edgeSubdivision > 24)
      console.info('High value for \'edgeSubdivision\'. This can slow down the simulation.');
    else if (edgeSubdivision < 1) {
      edgeSubdivision = fields.edgeSubdivision.defaultValue;
      console.error('\'edgeSubdivision\' must be greater or equal to 1. Value reset to ' + edgeSubdivision + '.');
    }

    let rimBeamNumber = fields.rimBeamNumber.value;
    if (rimBeamNumber < 3) {
      rimBeamNumber = 3;
      console.error('\'rimBeamNumber\' must be greater or equal to 3. Value reset to ' + rimBeamNumber + '.');
    }

    let thickness = fields.thickness.value;
    if (thickness <= 0) {
      thickness = fields.thickness.defaultValue;
      console.error('\'thickness\' must be strictly positive. Value reset to ' + thickness + '.');
    }

    let rimBeamThickness = fields.rimBeamThickness.value;
    if (rimBeamThickness <= 0) {
      rimBeamThickness = fields.rimBeamThickness.defaultValue;
      console.error('\'rimBeamThickness\' must be strictly positive. Value reset to ' + rimBeamThickness + '.');
    } else if (rimBeamThickness > thickness) {
      rimBeamThickness = thickness;
      console.error('\'rimBeamThickness\' must be greater or equal to \'thickness\'. Value reset to ' + thickness + '.');
    }

    let tireRadius = fields.tireRadius.value;
    if (tireRadius <= 0) {
      tireRadius = fields.tireRadius.defaultValue;
      console.error('\'tireRadius\' must be strictly positive. Value reset to ' + tireRadius + '.');
    }

    let curvatureFactor = fields.curvatureFactor.value;
    if (curvatureFactor < 0 || curvatureFactor > 1) {
      curvatureFactor = fields.curvatureFactor.defaultValue;
      console.error('\'curvatureFactor\' must be in the interval [0,1]. Value reset to ' + curvatureFactor + '.');
    }

    let rimRadius = fields.rimRadius.value;
    if (rimRadius <= 0) {
      rimRadius = tireRadius * 0.5;
      console.error('\'rimRadius\' must be strictly positive. Value reset to ' + rimRadius + '.');
    } else if (rimRadius > (tireRadius - (thickness * 0.5)  * curvatureFactor)) {
      rimRadius = tireRadius * 0.5;
      console.error('\'rimRadius\' must be smaller than \'tireRadius\' minus half of the \'thickness\' multiplied by the \'curvatureFactor\. Value reset to ' + rimRadius + '.');
    }

    let rimBeamWidth = fields.rimBeamWidth.value;
    if (rimBeamWidth <= 0) {
      rimBeamWidth = fields.rimBeamWidth.defaultValue;
      console.error('\'rimBeamWidth\' must be strictly positive. Value reset to ' + rimBeamWidth + '.');
    } else if (rimBeamWidth >= rimRadius) {
      rimBeamWidth = fields.rimBeamWidth.defaultValue;
      console.error('\'rimBeamWidth\' must be smaller than \'rimRadius\'. Value reset to ' + rimBeamWidth + '.');
    }

    let centralInnerRadius = fields.centralInnerRadius.value;
    if (centralInnerRadius <= 0) {
      centralInnerRadius = fields.centralInnerRadius.defaultValue;
      console.error('\'centralInnerRadius\' must be strictly positive. Value reset to ' + centralInnerRadius + '.');
    }

    let centralOuterRadius = fields.centralOuterRadius.value;
    if (centralOuterRadius <= 0) {
      centralOuterRadius = fields.centralOuterRadius.defaultValue;
      console.error('\'centralOuterRadius\' must be strictly positive. Value reset to ' + centralOuterRadius + '.');
    } else if (centralOuterRadius <= centralInnerRadius) {
      centralOuterRadius = centralInnerRadius;
      console.error('\'centralOuterRadius\' must be greater than \'centralInnerRadius\'. Value reset to ' + centralOuterRadius + '.');
    } else if (centralOuterRadius >= rimRadius) {
      centralOuterRadius = rimRadius;
      console.error('\'centralOuterRadius\' must be smaller than \'rimRadius\'. Value reset to ' + centralOuterRadius + '.');
    }

    let rimBeamOffset = fields.rimBeamOffset.value;
    let maxRimBeamOffset = (thickness - rimBeamThickness) * 0.5;
    if (rimBeamOffset > maxRimBeamOffset) {
      rimBeamOffset = maxRimBeamOffset;
      console.error('\'rimBeamOffset\' must be smaller or equal to \'thickness\' minus \'rimBeamThickness\', divided by two. Value reset to ' + rimBeamOffset + '.');
    }
  >%
  Slot {
    type "vehicle wheel"
    endPoint Solid {
      children [
        DEF WHEEL_SLOT Group {
          children IS logoSlot
        }
        Transform{
          %< if (fields.wheelSide.value) { >%
            rotation 0 0 1 3.141578
          %< } >%
          children[
            DEF TIRE Shape {
              appearance IS tireAppearance
              geometry IndexedFaceSet {
                coord Coordinate {
                  point [
                    %<
                      let circles = [];
                      circles[0] = wbgeometry.circle(rimRadius, subdivision, {x: 0, y: 0}, 0);
                      let beta = Math.PI / (2 * edgeSubdivision);
                      for (let i = 0; i <= edgeSubdivision; ++i)
                        circles[i + 1] = wbgeometry.circle(tireRadius - (thickness * 0.5)  * curvatureFactor *  (1 - Math.sin(beta * i)), subdivision, {x: 0, y: 0}, 0);
                    >%
                    
                    # top inner
                    %< for (let i = 0; i < circles[0].length; ++i) { >%
                      %<= thickness * 0.5 >% %<= -circles[0][i].x >% %<= circles[0][i].y >%
                    %< } >%

                    %< for (let i = 0; i <= edgeSubdivision; ++i) { >%
                      %< for (let j = 0; j < circles[i+1].length; ++j) { >%
                        %<= thickness * 0.5 * (1 - curvatureFactor * (1 - Math.cos(beta * i))) >% %<= -circles[i+1][j].x >% %<= circles[i+1][j].y >%
                      %< } >%
                    %< } >%

                    %< for (let i = 0; i <= edgeSubdivision; ++i) { >%
                      %< for (let j = 0; j < circles[(edgeSubdivision - i) + 1].length; ++j) { >%
                        %<= - thickness * 0.5 * (1 - curvatureFactor * (1 - Math.sin(beta * i))) >% %<= -circles[(edgeSubdivision - i) + 1][j].x >% %<= circles[(edgeSubdivision - i) + 1][j].y >%
                      %< } >%
                    %< } >%

                    # bottom inner
                    %< for (let i = 0; i < circles[0].length; ++i) { >%
                    %<= - thickness * 0.5 >% %<= -circles[0][i].x >% %<= circles[0][i].y >%
                    %< } >%

                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    # top inner
                    %< for (let i = 0; i <= subdivision; ++i) { >%
                      0 %<= 10 * i / subdivision >%
                    %< } >%

                    %< for (let j = 0; j <= edgeSubdivision; ++j) { >%
                      %< for (let i = 0; i <= subdivision; ++i) { >%
                        %<= 0.125 + 0.125 * j / edgeSubdivision >% %<= 10 * i / subdivision >%
                      %< } >%
                    %< } >%

                    %< for (let j = 0; j <= edgeSubdivision; ++j) { >%
                      %< for (let i = 0; i <= subdivision; ++i) { >%
                        %<= 0.75 + 0.125 * j / edgeSubdivision >% %<= 10 * i / subdivision >%
                      %< } >%
                    %< } >%

                    # bottom inner
                    %< for (let i = 0; i <= subdivision; ++i) { >%
                      1 %<= 10 * i / subdivision >%
                    %< } >%
                  ]
                }
                coordIndex [
                  %<
                    let offset = [0];
                    for (let i = 1; i <= (3 + 2 * edgeSubdivision); ++i)
                      offset[i] = (subdivision + 1) * i;
                  >%
                  %< for (let j = 0; j <= (2 + 2 * edgeSubdivision); ++j) { >%
                    %< for (let i = 0; i <= subdivision - 1; ++i) { >%
                      %<= offset[j] + i >% %<= offset[j] + i + 1 >% %<= offset[j + 1] + i + 1 >% -1
                      %<= offset[j + 1] + i + 1 >% %<= offset[j + 1] + i >% %<= offset[j] + i >% -1
                    %< } >%
                  %< } >%
                ]
                texCoordIndex [
                  %< for (let j = 0; j <= (2 + 2 * edgeSubdivision); ++j) { >%
                    %< for (let i = 0; i <= subdivision - 1; ++i) { >%
                      %<= offset[j] + i >% %<= offset[j] + i + 1 >% %<= offset[j + 1] + i + 1 >% -1
                      %<= offset[j + 1] + i + 1 >% %<= offset[j + 1] + i >% %<= offset[j] + i >% -1
                    %< } >%
                  %< } >%
                ]
                creaseAngle 1.5
              }
            }
          ]
        }
        DEF RIM Group {
          children [
            # Round contour
            Shape {
              appearance IS rimAppearance
              geometry IndexedFaceSet {
                coord Coordinate {
                  point [
                    %<
                      const rimOuterCircle = wbgeometry.circle(rimRadius, subdivision, {x: 0, y: 0}, 0);
                      const rimInnerCircle = wbgeometry.circle(rimRadius * 0.9, subdivision, {x: 0, y: 0}, 0);
                    >%

                    # top outer
                    %< for (let i = 0; i < rimOuterCircle.length; ++i) { >%
                      %<= -thickness * 0.5 >% %<= rimOuterCircle[i].x >% %<= rimOuterCircle[i].y >%
                    %< } >%

                    # top inner
                    %< for (let i = 0; i < rimInnerCircle.length; ++i) { >%
                      %<= -thickness * 0.5 >% %<= rimInnerCircle[i].x >% %<= rimInnerCircle[i].y >%
                    %< } >%

                    # bottom inner
                    %< for (let i = 0; i < rimInnerCircle.length; ++i) { >%
                      %<= thickness * 0.5 >% %<= rimInnerCircle[i].x >% %<= rimInnerCircle[i].y >%
                    %< } >%

                    # bottom outer
                    %< for (let i = 0; i < rimOuterCircle.length; ++i) { >%
                      %<= thickness * 0.5 >% %<= rimOuterCircle[i].x >% %<= rimOuterCircle[i].y >%
                    %< } >%
                  ]
                }
                coordIndex [
                  %<
                    offset = [0];
                    for (let i = 1; i <= 3; ++i)
                      offset[i] = (subdivision + 1) * i;
                  >%
                  %< for (let j = 0; j <= 2; ++j) { >%
                    %< for (let i = 0; i <= subdivision - 1; ++i) { >%
                      %<= offset[j] + i + 1 >% %<= offset[j] + i>% %<= offset[j + 1] + i>% -1
                      %<= offset[j + 1] + i>% %<= offset[j + 1] + i  + 1 >% %<= offset[j] + i + 1 >% -1
                    %< } >%
                  %< } >%
                ]
                creaseAngle %<= 2 * Math.PI / subdivision + 0.01 >%
              }
            }
            # center
            Shape {
              appearance IS rimAppearance
              geometry IndexedFaceSet {
                coord Coordinate {
                  point [
                    %<
                      let centralCircles = [];
                      centralCircles[0] = wbgeometry.circle(centralInnerRadius, rimBeamNumber, {x: 0, y: 0}, 0);
                      beta = Math.atan2(rimBeamWidth * 0.5, centralOuterRadius);
                      centralCircles[1] = wbgeometry.circle(centralOuterRadius, rimBeamNumber, {x: 0, y: 0}, beta);
                      centralCircles[2] = wbgeometry.circle(centralOuterRadius, rimBeamNumber, {x: 0, y: 0}, -beta);
                      centralCircles[3] = wbgeometry.circle(rimRadius, rimBeamNumber, {x: 0, y: 0}, 0);
                      beta = Math.atan2(rimBeamWidth / 2, rimRadius);
                      centralCircles[4] = wbgeometry.circle(rimRadius, rimBeamNumber, {x: 0, y: 0}, beta);
                      centralCircles[5] = wbgeometry.circle(rimRadius, rimBeamNumber, {x: 0, y: 0}, -beta);
                      let centralOffset = [];
                      for (let i = 0; i <= 10; ++i)
                        centralOffset[i] = (rimBeamNumber + 1) * i;
                    >%
                    # Top part
                    ## Center
                    %<= -rimBeamThickness / 2.5 - rimBeamOffset/2 >% 0 0
                    %< for (let i = 0; i < centralCircles[0].length; ++i) { >%
                      %<= -rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[0][i].x >% %<= centralCircles[0][i].y >%
                    %< } >%
                    ## Between beams
                    %< for (let i = 0; i < centralCircles[1].length; ++i) { >%
                      %<= -rimBeamThickness / 2.5 - rimBeamOffset/2 >% %<= centralCircles[1][i].x >% %<= centralCircles[1][i].y >%
                    %< } >%
                     %< for (let i = 0; i < centralCircles[2].length; ++i) { >%
                      %<= -rimBeamThickness / 2.5 - rimBeamOffset/2 >% %<= centralCircles[2][i].x >% %<= centralCircles[2][i].y >%
                    %< } >%
                    ## Beams
                    %< for (let i = 0; i < centralCircles[3].length; ++i) { >%
                      %<= -rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[3][i].x >% %<= centralCircles[3][i].y >%
                    %< } >%
                     %< for (let i = 0; i < centralCircles[4].length; ++i) { >%
                      %<= -rimBeamThickness / 2.5 - rimBeamOffset/2 >% %<= centralCircles[4][i].x >% %<= centralCircles[4][i].y >%
                    %< } >%
                    %< for (let i = 0; i < centralCircles[5].length; ++i) { >%
                      %<= -rimBeamThickness / 2.5 - rimBeamOffset/2 >% %<= centralCircles[5][i].x >% %<= centralCircles[5][i].y >%
                    %< } >%

                    # side
                    ## Between beams
                    %< for (let i = 0; i < centralCircles[1].length; ++i) { >%
                      %<= rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[1][i].x >% %<= centralCircles[1][i].y >%
                    %< } >%
                    %< for (let i = 0; i < centralCircles[2].length; ++i) { >%
                      %<= rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[2][i].x >% %<= centralCircles[2][i].y >%
                    %< } >%
                    ## Beams
                    %< for (let i = 0; i < centralCircles[4].length; ++i) { >%
                      %<= rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[4][i].x >% %<= centralCircles[4][i].y >%
                    %< } >%
                    %< for (let i = 0; i < centralCircles[5].length; ++i) { >%
                      %<= rimBeamThickness * 0.5 - rimBeamOffset/2 >% %<= centralCircles[5][i].x >% %<= centralCircles[5][i].y >%
                    %< } >%

                    # bottom
                    %<= rimBeamThickness * 0.5 - rimBeamOffset/2 >% 0 0
                  ]
                }
                coordIndex [
                  # Top part
                  ## Center
                  %< for (let i = 0; i <= rimBeamNumber; ++i) { >%
                    0 %<= i + 1 >% %<= i >% -1
                  %< } >%
                  ## Between beams
                  %< for (let i = 0; i <= rimBeamNumber; ++i) { >%
                    %<= i >% %<= i + 1 >% %<= centralOffset[2] + i + 1 >% -1
                    %<= centralOffset[2] + i + 1 >% %<= centralOffset[1] + i >% %<= i >% -1
                  %< } >%
                  ## Beams
                  %< for (let i = 0; i <= rimBeamNumber; ++i) { >%
                    %<= i >% %<= centralOffset[1] + i >% %<= centralOffset[4] + i >% -1
                    %<= centralOffset[4] + i >% %<= centralOffset[3] + i >% %<= i >% -1
                  %< } >%
                  %< for (let i = 0; i <= rimBeamNumber; ++i) { >%
                    %<= i >% %<= centralOffset[3] + i >% %<= centralOffset[5] + i >% -1
                    %<= centralOffset[5] + i >% %<= centralOffset[2] + i >% %<= i >% -1
                  %< } >%

                  # Side
                  ## Between beams
                  %< for (let i = 1; i <= rimBeamNumber; ++i) { >%
                    %<= centralOffset[1] + i >% %<= centralOffset[2] + i + 1 >% %<= centralOffset[7] + i + 1 >% -1
                    %<= centralOffset[7] + i + 1 >% %<= centralOffset[6] + i >% %<= centralOffset[1] + i >% -1
                  %< } >%
                  ## Beams
                  %< for (let i = 1; i <= rimBeamNumber; ++i) { >%
                    %<= centralOffset[1] + i >% %<= centralOffset[6] + i >% %<= centralOffset[8] + i >% -1
                    %<= centralOffset[8] + i >% %<= centralOffset[4] + i >% %<= centralOffset[1] + i >% -1
                  %< } >%
                  %< for (let i = 1; i <= rimBeamNumber; ++i) { >%
                    %<= centralOffset[2] + i >% %<= centralOffset[5] + i >% %<= centralOffset[9] + i >% -1
                    %<= centralOffset[9] + i >% %<= centralOffset[7] + i >% %<= centralOffset[2] + i >% -1
                  %< } >%

                  # Bottom
                  ## Beams
                  %< for (let i = 1; i <= rimBeamNumber; ++i) { >%
                    %<= centralOffset[8] + i >% %<= centralOffset[6] + i >% %<= centralOffset[7] + i >% -1
                    %<= centralOffset[7] + i >% %<= centralOffset[9] + i >% %<= centralOffset[8] + i >% -1
                  %< } >%
                  ## Center
                  %< for (let i = 1; i <= rimBeamNumber; ++i) { >%
                    %<= centralOffset[10] + 1 >% %<= centralOffset[7] + i >% %<= centralOffset[6] + i >% -1
                    %<= centralOffset[10] + 1 >% %<= centralOffset[6] + i >% %<= centralOffset[7] + i + 1 >% -1
                  %< } >%

                ]
              }
            }
          ]
        }
      ]
      name IS name
      model "vehicle wheel"
      %< if (fields.boundingObject.value) { >%
        contactMaterial IS contactMaterial
        boundingObject Transform {
          rotation 0 1 0 1.570796
          children [
            Cylinder {
              height %<= thickness >%
              radius %<= tireRadius >%
              subdivision %<= subdivision >%
            }
          ]
        }
        physics IS physics
      %< } >%
    }
  }
}
