#VRML_SIM R2021b utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# A customizable fence.
# Dimensions, path and appearance of the fence can be set.
# If subdivision is bigger than 1, B-Splines are used to interpolate path of the fence.
# This model was sponsored by the CTI project RO2IVSim (http://transport.epfl.ch/simulator-for-mobile-robots-and-intelligent-vehicles).
# template language: javascript

PROTO Fence [
  field SFVec3f      translation             0 0 0
  field SFRotation   rotation                0 1 0 0
  field SFString     name                    "fence"
  field SFString     model                   "fence"
  field MFColor      recognitionColors       [0.8 0.8 0.8]
  field SFFloat      height                  1.5                                                          # Defines the height of the fence.
  field SFFloat      poleGap                 0.5                                                          # Defines the distance between two consecutives poles.
  field SFFloat      poleRadius              0.04                                                         # Defines the radius of the poles.
  field SFString{"cylinder", "square", "diamond", "H"}
                     poleShape               "cylinder"                                                   # Defines the shape of the poles.
  field SFNode       poleAppearance          PBRAppearance {}                                             # Defines the appearance of the poles.
  field MFVec3f      path                    [0 0 0, 5 0 0]                                               # Defines the 3D path of the fence.
  field SFInt32      subdivision             -1                                                           # Defines the degree of interpolation using B-Splines (if the value is lower than 0, the interpolation is disabled).
  field SFInt32      horizontalBarsNumber    2                                                            # Defines the number of horizontal bars.
  field MFVec2f      horizontalBarShape      [0.06 0.02, 0.06 -0.02, -0.06 -0.02, -0.06 0.02, 0.06 0.02]  # Defines the shape 2D of the horizontal bars.
  field SFNode       horizontalBarAppearance PBRAppearance {}                                             # Defines the appearance of the horizontal bars.
  field SFNode       boundingObject          NULL                                                         # Is `Solid.boundingObject`.
  field SFFloat      creaseAngle             0.3                                                          # Defines the creaseAngle of the horizontal bar.
  hiddenField SFNode appearance              NULL                                                         # For backward compatibility warning.
]
{
  %{
    import * as wbgeometry from 'modules/webots/wbgeometry.js';
    import * as wbvector2 from 'modules/webots/wbvector2.js';

    // parameter checking
    let poleGap = fields.poleGap.value;
    if (poleGap <= 0.0) {
      poleGap = fields.poleGap.defaultValue;
      console.error('\'poleGap\' must be strictly positive. Value reset to ' + poleGap + '.');
    }
    let height = fields.height.value;
    if (height <= 0.0) {
      height = fields.height.defaultValue;
      console.error('\'height\' must be strictly positive. Value reset to ' + height + '.');
    }
    let poleRadius = fields.poleRadius.value;
    if (poleRadius <= 0.0) {
      poleRadius = fields.poleRadius.defaultValue;
      console.error('\'poleRadius\' must be strictly positive. Value reset to ' + poleRadius + '.');
    }
    let path = fields.path.value;
    if (Object.keys(path).length < 2) {
      path = fields.path.defaultValue;
      console.error('\'path\' must have at least two components. Value reset to default value.');
    }

    let poleShape = fields.poleShape.value;
    if (fields.appearance.value !== fields.appearance.defaultValue)
      console.error('Field \'appearance\' is deprecated, please use \'poleAppearance\' and \'horizontalBarAppearance\' instead.');

    const horizontalBarsNumber = fields.horizontalBarsNumber.value;
    let subdivision = fields.subdivision.value;

    // use B-Spline interpolation if subdivision is greater than 1
    if (subdivision > 0)
      path = wbgeometry.bSpline3(Object.values(path), subdivision); // TODO.. MF => PURE ARRAY NOT OBJ ARRAY

    let nbPath = Object.keys(path).length;

    // compute pole positions
    let polePositions = [];
    let offset = -poleRadius;
    for (let i = 0; i < nbPath - 1; ++i) {
      let distance = wbvector2.distance({x: path[i].x, y: path[i].z}, {x: path[i+1].x, y: path[i+1].z});
      let distanceTotal = offset + distance;
      let poleNb = Math.floor(distanceTotal / poleGap);
      let start = (i === 1) ? 0 : 1; // make sure first pole starts at beginning
      for (let j = start; j <= poleNb; ++j) {
        let ratio = (poleGap * j - offset) / distance;
        let point = {x: (1 - ratio) * path[i].x + ratio * path[i+1].x, y: (1 - ratio) * path[i].y + ratio * path[i+1].y, z: (1 - ratio) * path[i].z + ratio * path[i+1].z};
        point.y = point.y + height * 0.5;
        polePositions.push(point);
      }
      offset = distanceTotal - poleNb * poleGap;
    }
    let nbPoles = polePositions.length;
  }%
  Solid {
    translation IS translation
    rotation IS rotation
    recognitionColors [
      %{ if (fields.horizontalBarAppearance.value !== 'undefined') { }%
        %{ if (fields.horizontalBarAppearance.value.fields.baseColor !== 'undefined') { }%
          %{ let color = fields.horizontalBarAppearance.value.fields.baseColor.value; }%
          %{= color.r }% %{= color.g }% %{= color.b }%
        %{ } else if (fields.horizontalBarAppearance.value.fields.material !== 'undefined' && fields.horizontalBarAppearance.value.fields.material.value !== 'undefined') { }%
          %{ let color = fields.horizontalBarAppearance.value.fields.material.value.fields.diffuseColor.value; }%
          %{= color.r }% %{= color.g }% %{= color.b }%
        %{ } }%
      %{ } }%
      %{ if (fields.poleAppearance.value !== 'undefined') { }%
        %{ if (fields.poleAppearance.value.fields.baseColor !== 'undefined') { }%
          %{ let color = fields.poleAppearance.value.fields.baseColor.value; }%
          %{= color.r }% %{= color.g }% %{= color.b }%
        %{ } else if (fields.poleAppearance.value.fields.material !== 'undefined' && fields.poleAppearance.value.fields.material.value !== 'undefined') { }%
          %{ let color = fields.poleAppearance.value.fields.material.value.fields.diffuseColor.value; }%
          %{= color.r }% %{= color.g }% %{= color.b }%
        %{ } }%
      %{ } }%
    ]
    children [
      # horizontal bars
      %{ for (let j = 0; j <= horizontalBarsNumber - 1; ++j) { }%
        %{
          let horizontalBarsHeight = height * 0.5;
          if (horizontalBarsNumber > 1)
            horizontalBarsHeight = height * ((j / (horizontalBarsNumber - 1)) * 0.8 + 0.1);
        }%
        Transform {
          translation 0 %{= horizontalBarsHeight }% 0
          children [
            %{ if (j === 0) { }%
              DEF HORIZONTALE_BAR Shape {
                appearance IS horizontalBarAppearance
                geometry Extrusion {
                  spine IS path
                  splineSubdivision IS subdivision
                  creaseAngle IS creaseAngle
                  crossSection IS horizontalBarShape
                }
              }
            %{ } else { }%
              USE HORIZONTALE_BAR
            %{ } }%
          ]
        }
      %{ } }%
      # poles
      Shape {
        appearance IS poleAppearance
        geometry IndexedFaceSet {
          coord Coordinate {
            point [
              %{
                let circleSubdivision = (poleShape === 'cylinder' || poleShape === 'H') ? 12 : 4;
                let angleOffset = (poleShape === 'square') ? 0.7854 : 0;
                let circle = wbgeometry.circle(poleRadius, circleSubdivision, {x: 0, y: 0}, angleOffset);
                if (poleShape === 'H') {
                  circle = [];
                  circle.push({x: -0.25 * poleRadius, y: 0.5 * poleRadius});
                  circle.push({x: -0.25 * poleRadius, y: -0.5 * poleRadius});
                  circle.push({x: -poleRadius, y: -0.5 * poleRadius});
                  circle.push({x: -poleRadius, y: -poleRadius});
                  circle.push({x: poleRadius, y: -poleRadius});
                  circle.push({x: poleRadius, y: -0.5 * poleRadius});
                  circle.push({x: 0.25 * poleRadius, y: -0.5 * poleRadius});
                  circle.push({x: 0.25 * poleRadius, y: 0.5 * poleRadius});
                  circle.push({x: poleRadius, y: 0.5 * poleRadius});
                  circle.push({x: poleRadius, y: poleRadius});
                  circle.push({x: -poleRadius, y: poleRadius});
                  circle.push({x: -poleRadius, y: 0.5 * poleRadius});
                  circle.push({x: -0.25 * poleRadius, y: 0.5 * poleRadius});
                }
              }%
              %{ for (let i = 0; i < nbPoles; ++i) { }%
                %{
                  let dx = 0;
                  let dy = 0;
                  if (i === 0) {
                    if (nbPoles > 2) {
                      dx = polePositions[1].x - polePositions[0].x;
                      dy = polePositions[1].z - polePositions[0].z;
                    } else {
                      dx = path[1].x - path[0].x;
                      dy = path[1].z - path[0].z;
                    }
                  } else if (i === nbPoles - 1) {
                    dx = polePositions[nbPoles - 1].x - polePositions[nbPoles - 2].x;
                    dy = polePositions[nbPoles - 1].z - polePositions[nbPoles - 2].z;
                  } else {
                    dx = polePositions[i + 1].x - polePositions[i - 1].x;
                    dy = polePositions[i + 1].z - polePositions[i - 1].z;
                  }
                  let angle = Math.atan2(dy, dx);
                }%
                # Top part
                %{ for (let k = 0; k < circle.length; ++k) { }%
                  %{= polePositions[i].x + circle[k].x * Math.cos(angle) - circle[k].y * Math.sin(angle) }% %{= polePositions[i].y + 0.5 * height }% %{= polePositions[i].z + circle[k].x * Math.sin(angle) + circle[k].y * Math.cos(angle) }%
                %{ } }%
                # Bottom part
                %{ for (let k = 0; k < circle.length; ++k) { }%
                  %{= polePositions[i].x + circle[k].x * Math.cos(angle) - circle[k].y * Math.sin(angle) }% %{= polePositions[i].y - 0.5 * height }% %{= polePositions[i].z + circle[k].x * Math.sin(angle) + circle[k].y * Math.cos(angle) }%
                %{ } }%
              %{ } }%
            ]
          }
          texCoord TextureCoordinate {
            point [
              # Top part of sides
              %{ for (let j = 0; j < circle.length; ++j) { }%
                %{= 2 * poleRadius * Math.PI * j / circleSubdivision }% %{= 0.5 * height }%
              %{ } }%
              # Bottom part of sides
              %{ for (let j = 0; j < circle.length; ++j) { }%
                %{= 2 * poleRadius * Math.PI * j / circleSubdivision }% %{= - 0.5 * height }%
              %{ } }%
              # Top and bottom faces
              %{ for (let i = 0; i <= circleSubdivision; ++i) { }%
                %{= poleRadius * Math.cos(2 * Math.PI * i / circleSubdivision) }% %{= poleRadius * Math.sin(2 * Math.PI * i / circleSubdivision) }%
              %{ } }%
            ]
          }
          coordIndex [
            %{ let skip = 2 * (circleSubdivision + 1); }%
            %{ for (let i = 0; i <= nbPoles - 1; ++i) { }%
              # Top part
              %{ for (let j = 0; j <= circleSubdivision; ++j) { }% %{= i * skip + circleSubdivision - j }% %{ } }% -1
              # Bottom part
              %{ for (let j = 0; j <= circleSubdivision; ++j) { }% %{= i * skip + j + circleSubdivision + 1 }% %{ } }% -1
              # Sides
              %{ for (let j = 0; j <= circleSubdivision - 1; ++j) { }%
                %{= i * skip + j }% %{= i * skip + j + 1 }% %{= i * skip + j + circleSubdivision + 2 }% %{= i * skip + j + circleSubdivision + 1 }% -1
              %{ } }%
            %{ } }%
          ]
          texCoordIndex [
            %{ for (let i = 0; i <= nbPoles - 1; ++i) { }%
              # Top part
              %{ for (let j = 0; j <= circleSubdivision; ++j) { }% %{= j + 2 * (circleSubdivision + 1) }% %{ } }% -1
              # Bottom part
              %{ for (let j = 0; j <= circleSubdivision; ++j) { }% %{= j + 2 * (circleSubdivision + 1) }% %{ } }% -1
              # Sides
              %{ for (let j = 0; j <= circleSubdivision - 1; ++j) { }%
                %{= j }% %{= j + 1 }% %{= j + circleSubdivision + 2 }% %{= j + circleSubdivision + 1 }% -1
              %{ } }%
            %{ } }%
          ]
          creaseAngle 0.6
        }
      }
    ]
    name IS name
    model IS model
    recognitionColors IS recognitionColors
    boundingObject IS boundingObject
  }
}
