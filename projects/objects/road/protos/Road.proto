#VRML_SIM R2020a utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# tags: static
# A fully customizable road, the number of lanes, the dimensions and the path of the road is configurable.
# For each line separating two lanes it is possible to configure if this one is continuous or dashed.
# B-Spline can be used in order to interpolate the path of the road and an optional border can be enable.
# The boundingObject of each border and the road itself can be independently enable or disable.
# This model was sponsored by the CTI project RO2IVSim (http://transport.epfl.ch/simulator-for-mobile-robots-and-intelligent-vehicles).

PROTO Road [
  field        SFVec3f              translation               0 0 0
  field        SFRotation           rotation                  0 1 0 0
  field        SFString             name                      "road"                  # Optionally defines the street name
  field        SFString             id                        ""                      # Optionally defines a unique ID. A unique ID is required to use the SUMO exporter.
  field        SFString             startJunction             ""                      # Optionally defines a reference to the Crossroad connected at the first Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFString             endJunction               ""                      # Optionally defines a reference to the Crossroad connected at the last Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFFloat              width                     7                       # Defines the total width of the road (excluding sidewalk).
  field        SFInt32              numberOfLanes             2                       # Defines the number of lanes (used for the texture mapping).
  field        SFInt32              numberOfForwardLanes      1                       # Defines the number of forward lanes. (this is an information with no impact on the graphical shape).
  field        SFFloat              speedLimit                -1.0                    # Optionally defines the speed limit. The recommended unit is meter per seconds.
  field        MFNode{RoadLine {}}  lines                     [ RoadLine { } ]        # Defines the property of each line separating two lanes.
  field        SFFloat              roadBorderHeight          0.15                    # Defines the height of the sidewalk.
  field        MFFloat              roadBorderWidth           [ 0.8 ]                 # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               road                      TRUE                    # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               rightBorder               TRUE                    # Defines whether the road should have a right sidewalk.
  field        SFBool               leftBorder                TRUE                    # Defines whether the road should have a left sidewalk.
  field        SFBool               rightBarrier              FALSE                   # Defines whether the road should have a right barrier.
  field        SFBool               leftBarrier               FALSE                   # Defines whether the road should have a left barrier.
  field        SFBool               bottom                    FALSE                   # Defines whether the road bottom should be displayed (useful in case of bridge).
  field        MFVec3f              wayPoints                 [ 0 0 0, 0 0 1 ]        # Defines the path of the road.
  field        MFFloat              roadTilt                  [ 0, 0]                 # Defines the tilting angle corresponding to each way-point (if there are less values than way-points, 0 is used for the last remaining way-points).
  field        MFFloat              startingAngle             []                      # Optionally defines the angle of the road at the first way-point
  field        MFFloat              endingAngle               []                      # Optionally defines the angle of the road at the lasst way-point
  field        MFString             startLine                 []                      # Optionally defines the texture used for the road line at the first way-point for each lane. If the string is empty, no road line will be added for the corresponding lane. The two textures `textures/road_line_dashed.png` and `textures/road_line_triangle.png` may be used in this field.
  field        MFString             endLine                   []                      # Optionally defines the texture used for the road line at the last way-point for each lane. If the string is empty, no road line will be added for the corresponding lane.
  field        SFInt32              splineSubdivision         4                       # Defines the degree of interpolation using B-Splines (if the value is lower than 0, the interpolation is disabled).
  field        SFNode               appearance                Asphalt { }             # Defines the appearance of the road.
  field        SFNode               pavementAppearance        StonePavement { }       # Defines the appearance of the sidewalk.
  field        MFString             bottomTexture             []                      # Defines the texture to be used for the bottom of the road.
  field        SFString             turnLanesForward          ""                      # Defines painted arrows before the end of the lanes using the same format as the OSM "turn:lanes:forward" key (e.g. "through|left;through|none"). Please refer to the corresponding OSM tag: http://wiki.openstreetmap.org/wiki/Key:turn.
  field        SFString             turnLanesBackward         ""                      # Same as `turnLanesForward` but for the OSM "turn:lanes:backward" key
  field        SFBool               locked                    TRUE                    # Is `Solid.locked`.
  field        SFBool               roadBoundingObject        FALSE                   # Defines whether the road should have a bounding object.
  field        SFBool               rightBorderBoundingObject FALSE                   # Defines whether the right sidewalk should have a bounding object.
  field        SFBool               leftBorderBoundingObject  FALSE                   # Defines whether the left sidewalk should have a bounding object.
  field        SFBool               rightBarrierBoundingObject TRUE                   # Defines whether the right crash barrier (if any) should have a bounding object.
  field        SFBool               leftBarrierBoundingObject TRUE                    # Defines whether the left crash barrier (if any) should have a bounding object.
  field        SFBool               castShadows               FALSE                   # Defines whether the road should cast shadows.
  field        SFString             contactMaterial           "default"               # Is `Solid.contactMaterial`.

  hiddenField  MFBool               dashedLine          TRUE                          # Deprecated in Webots R2018c.
]
{
  %{
    local wbcore = require('wbcore')
    local wbgeometry = require('wbgeometry')
    local wbstring = require('wbstring')
    local wbvector2 = require('wbvector2')
    local wbvector3 = require('wbvector3')

    -- fields checks
    local width = fields.width.value
    if width < 0 then
      io.stderr:write("'width' must be greater than 0\n")
      width = fields.width.defaultValue
    end
    local barrierOffset = 0.06 + 0.05 * width
    local numberOfLanes = fields.numberOfLanes.value
    if numberOfLanes < 1 then
      io.stderr:write("'numberOfLanes' must be greater than 1\n")
      numberOfLanes = fields.numberOfLanes.defaultValue
    end
    local borderHeight = fields.roadBorderHeight.value
    local borderWidth = fields.roadBorderWidth.value
    local nbBorderWidthPoint = wbcore.tablelength(borderWidth)

    for j = 1, nbBorderWidthPoint do
      if borderWidth[j] < 0 then
        io.stderr:write("'roadBorderWidth' elements must be positive\n")
        borderWidth[j] = 0
      end
    end

    local roadLines = fields.lines.value
    for i = 1, wbcore.tablelength(roadLines) do
      if roadLines[i].node_name ~= "RoadLine" then
        roadLines[i] = nil
        io.stderr:write("Only 'RoadLine' nodes should be added in the 'lines' field.\n")
      end
    end

    local textureCoordinateRatio = 0.2
    local defaultLineWidth = 0.075
    local heightOffset  = 0.01
    local dashedLine    = fields.dashedLine.value
    local rightBorder   = fields.rightBorder.value
    local leftBorder    = fields.leftBorder.value
    local rightBarrier  = fields.rightBarrier.value
    local leftBarrier   = fields.leftBarrier.value
    local bottom        = fields.bottom.value
    local road          = fields.road.value
    local roadBO        = fields.roadBoundingObject.value
    local rightBorderBO = fields.rightBorderBoundingObject.value
    local leftBorderBO  = fields.leftBorderBoundingObject.value
    local startingAngle = fields.startingAngle.value
    local endingAngle   = fields.endingAngle.value
    local startLine     = fields.startLine.value
    local endLine       = fields.endLine.value
    local bottomTexture = fields.bottomTexture.value
    local useBottomTexture = false
    if wbcore.tablelength(bottomTexture) > 0 then
      useBottomTexture = true
    end
    local nbStartLine   = wbcore.tablelength(startLine)
    local nbEndLine     = wbcore.tablelength(endLine)
    if nbStartLine > numberOfLanes then
      nbStartLine = numberOfLanes
    end
    if nbEndLine > numberOfLanes then
      nbEndLine = numberOfLanes
    end

    local wayPoints = fields.wayPoints.value
    local nbWayPoint = wbcore.tablelength(wayPoints)

    local borderWidthOriginal = {}
    if nbBorderWidthPoint > 0 then
      for j = 1, nbWayPoint + 1 do
        if borderWidth[j] == nil then
          borderWidthOriginal[j] = borderWidthOriginal[j - 1]
        else
          borderWidthOriginal[j] = borderWidth[j]
        end
      end
    end

    local originalTilt = fields.roadTilt.value
    for j = 1, nbWayPoint do
      if originalTilt[j] == nil then
        originalTilt[j] = 0
      end
    end
    originalTilt[nbWayPoint + 1] = originalTilt[nbWayPoint]

    local splineSubdivision = fields.splineSubdivision.value
    -- use B-Spline interpolation if splineSubdivision is greater than 1
    if splineSubdivision > 0 then
      wayPoints = wbgeometry.bspline3D(wayPoints, splineSubdivision)
    end
    nbWayPoint = wbcore.tablelength(wayPoints)

    local tilt = {}
    if splineSubdivision > 1 then
      for j = 1, nbWayPoint do
        local ratio = ((j -1) % splineSubdivision) / splineSubdivision
        local index = math.floor((j-1)/splineSubdivision + 1)
        tilt[j]        = originalTilt[index]       * (1 - ratio) + originalTilt[index + 1]       * ratio
        if nbBorderWidthPoint > 0 then
          borderWidth[j] = borderWidthOriginal[index] * (1 - ratio) + borderWidthOriginal[index + 1] * ratio
        end
      end
    else
      if nbBorderWidthPoint > 0 then
        borderWidth = borderWidthOriginal
      end
      tilt = originalTilt
    end

    local angle = {}
    local distance = {}
    distance[0] = 0
    for i = 0, nbWayPoint - 1 do
      -- compute angle for each way-points
      if (i == nbWayPoint - 1 or i >= (nbWayPoint - 1 - splineSubdivision)) and endingAngle[1] ~= nil then
        -- last segment with ending angle set
        -- we use third order Spline approximation,
        -- therefore we want to adapt the angle of the road with a cubic ratio between last and second last way-points
        local ratio = 0
        if splineSubdivision > 0 then
          ratio = math.pow(((nbWayPoint - 1 - i)  / splineSubdivision), 3)
        end
        if i == 0 then
          angle[i] = endingAngle[1] * (1 - ratio) - wbvector2.angle({x=wayPoints[i+2].x, y=wayPoints[i+2].z} , {x=wayPoints[i+1].x, y=wayPoints[i+1].z}) * ratio
        else
          angle[i] = endingAngle[1] * (1 - ratio) - wbvector2.angle({x=wayPoints[i+1].x, y=wayPoints[i+1].z} , {x=wayPoints[i].x, y=wayPoints[i].z}) * ratio
        end
      elseif i > 0 and i > splineSubdivision then
        -- all the segments except first
        if i == nbWayPoint - 1 then
          angle[i] = -wbvector2.angle({x=wayPoints[i+1].x, y=wayPoints[i+1].z} , {x=wayPoints[i].x, y=wayPoints[i].z})
        else
          angle[i] = -wbvector2.angle({x=wayPoints[i+2].x, y=wayPoints[i+2].z} , {x=wayPoints[i].x, y=wayPoints[i].z})
        end
      elseif startingAngle[1] ~= nil then
        -- first segment with starting angle set
        local ratio = 0
        if splineSubdivision > 0 then
          ratio = math.pow((i / splineSubdivision), 3)
        end
        if i == nbWayPoint - 1 then
          angle[i] = startingAngle[1] * (1 - ratio) - wbvector2.angle({x=wayPoints[i+1].x, y=wayPoints[i+1].z}, {x=wayPoints[i].x, y=wayPoints[i].z}) * ratio
        else
          angle[i] = startingAngle[1] * (1 - ratio) - wbvector2.angle({x=wayPoints[i+2].x, y=wayPoints[i+2].z}, {x=wayPoints[i+1].x, y=wayPoints[i+1].z}) * ratio
        end
      else
        -- first segment if starting angle is not set
        if i == nbWayPoint - 1 then
          angle[i] = -wbvector2.angle({x=wayPoints[i+1].x, y=wayPoints[i+1].z}, {x=wayPoints[i].x, y=wayPoints[i].z})
        else
          angle[i] = -wbvector2.angle({x=wayPoints[i+2].x, y=wayPoints[i+2].z}, {x=wayPoints[i+1].x, y=wayPoints[i+1].z})
        end
      end

      -- compute distance (from beginning of road) for each way-points
      if i ~= 0 then
        distance[i] = distance[i-1] + wbvector3.distance(wayPoints[i+1], wayPoints[i])
      end
    end
  }%
  Solid {
    translation IS translation
    rotation IS rotation
    name IS name
    model "road"
    children [
      Group {
        children IS lines
      }
      # road
      %{ if road then }%
        DEF ROAD Solid {
          children [
            Shape {
              appearance IS appearance
              geometry DEF ROAD_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{= wayPoints[i+1].x - 0.5 * math.cos(angle[i]) * width }% %{= wayPoints[i+1].y - 0.5 * math.sin(tilt[i+1]) * width }% %{= wayPoints[i+1].z - 0.5 * math.sin(angle[i]) * width }%
                      %{= wayPoints[i+1].x + 0.5 * math.cos(angle[i]) * width }% %{= wayPoints[i+1].y + 0.5 * math.sin(tilt[i+1]) * width }% %{= wayPoints[i+1].z + 0.5 * math.sin(angle[i]) * width }%
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{= -0.5 * width * textureCoordinateRatio }% %{= distance[i] * textureCoordinateRatio }%
                      %{= 0.5 * width * textureCoordinateRatio }% %{= distance[i] * textureCoordinateRatio }%
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% -1
                    %{= 2 * i }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% -1
                    %{= 2 * i }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road ground"
          %{ if roadBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE ROAD_GEOMETRY
          %{ end }%
          recognitionColors [ 0.2 0.2 0.2 ]
          model "road"
        }
        # road signs (start)
        %{ for i = 0, nbStartLine - 1 do }%
          # if not same sign than previous lane
          %{ if startLine[i+1] ~= startLine[i] and startLine[i+1] ~= "" then }%
            %{
              local size = 1
              for j = i + 1, nbStartLine - 1 do
                if startLine[i+1] == startLine[j+1] then
                  size = size + 1
                else
                  break
                end
              end
            }%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %{= '"' .. startLine[i+1] .. '"' }% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF START_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ local heightDiff = 0.4 * (wayPoints[2].y - wayPoints[1].y) /  wbvector2.distance({ x = wayPoints[1].x; y = wayPoints[1].z }, { x = wayPoints[2].x; y = wayPoints[2].z }) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[0]) * width + wayPoints[1].x }%                             %{= wayPoints[1].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[1]) * width + heightOffset }%              %{= (i / numberOfLanes - 0.5)          * math.sin(angle[0]) * width + wayPoints[1].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[0]) * width + wayPoints[1].x }%                             %{= wayPoints[1].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[1]) * width + heightOffset }%              %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[0]) * width + wayPoints[1].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[0]) * width + wayPoints[1].x + 0.4 * math.sin(-angle[0]) }% %{= wayPoints[1].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[1]) * width + heightOffset + heightDiff }% %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[0]) * width + wayPoints[1].z + 0.4 * math.cos(angle[0]) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[0]) * width + wayPoints[1].x + 0.4 * math.sin(-angle[0]) }% %{= wayPoints[1].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[1]) * width + heightOffset + heightDiff }% %{= (i / numberOfLanes - 0.5)          * math.sin(angle[0]) * width + wayPoints[1].z + 0.4 * math.cos(angle[0]) }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %{= size * width / (0.4 * numberOfLanes) }% 0
                    %{= size * width / (0.4 * numberOfLanes) }% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 3 2 1
                ]
                texCoordIndex [
                  0 3 2 1
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %{ end }%
        %{ end }%
        # road signs (end)
        %{ for i = 0, nbEndLine - 1 do }%
          # if not same sign than previous lane
          %{ if endLine[i+1] ~= endLine[i] and endLine[i+1] ~= ""  then }%
            %{
              local size = 1
              for j = i + 1, nbEndLine - 1 do
                if endLine[i+1] == endLine[j+1] then
                  size = size + 1
                else
                  break
                end
              end
            }%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %{= '"' .. endLine[i+1] .. '"' }% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF END_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ local heightDiff = 0.4 * (wayPoints[nbWayPoint-1].y - wayPoints[nbWayPoint].y) /  wbvector2.distance({ x = wayPoints[nbWayPoint-1].x; y = wayPoints[nbWayPoint-1].z }, { x = wayPoints[nbWayPoint].x; y = wayPoints[nbWayPoint].z }) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x }%                                        %{= wayPoints[nbWayPoint].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[nbWayPoint]) * width + heightOffset }%              %{= (i / numberOfLanes - 0.5)          * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x }%                                        %{= wayPoints[nbWayPoint].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[nbWayPoint]) * width + heightOffset }%              %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z }%
                    %{= ((i + size) / numberOfLanes - 0.5) * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x - 0.4 * math.sin(-angle[nbWayPoint-1]) }% %{= wayPoints[nbWayPoint].y + ((i + size) / numberOfLanes - 0.5) * math.sin(tilt[nbWayPoint]) * width + heightOffset + heightDiff }% %{= ((i + size) / numberOfLanes - 0.5) * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z - 0.4 * math.cos(angle[nbWayPoint-1]) }%
                    %{= (i / numberOfLanes - 0.5)          * math.cos(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].x - 0.4 * math.sin(-angle[nbWayPoint-1]) }% %{= wayPoints[nbWayPoint].y + (i / numberOfLanes - 0.5)          * math.sin(tilt[nbWayPoint]) * width + heightOffset + heightDiff }% %{= (i / numberOfLanes - 0.5)          * math.sin(angle[nbWayPoint-1]) * width + wayPoints[nbWayPoint].z - 0.4 * math.cos(angle[nbWayPoint-1]) }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %{= size * width / (0.4 * numberOfLanes) }% 0
                    %{= size * width / (0.4 * numberOfLanes) }% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 1 2 3
                ]
                texCoordIndex [
                  0 1 2 3
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %{ end }%
        %{ end }%
        # lines
        %{ for j = 1, numberOfLanes - 1 do }%
          %{ if roadLines[j] == nil or (roadLines[j].fields.type.value ~= "none" and roadLines[j].fields.width.value > 0) then }%
            DEF LINES Solid {
              children [
                Shape {
                  appearance PBRAppearance {
                    %{ if roadLines[j] then }%
                      baseColor %{= roadLines[j].fields.color.value.r }% %{= roadLines[j].fields.color.value.g }% %{= roadLines[j].fields.color.value.b }%
                    %{ end }%
                    baseColorMap ImageTexture {
                      url [
                      %{ if (roadLines[j] and (roadLines[j].fields.type.value == "continuous" or roadLines[j].fields.type.value == "double")) or dashedLine[j] == false then }%
                        "textures/line_base_color.png"
                      %{ else }%
                        "textures/line_base_color_dashed.png"
                      %{ end }%
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      scale 1 0.2
                    }
                  }
                  geometry IndexedFaceSet {
                    coord Coordinate {
                      point [
                        %{
                          local lineWidth = defaultLineWidth
                          if roadLines[j] then
                            lineWidth = roadLines[j].fields.width.value / 2
                            if roadLines[j].fields.type.value == "double" then
                              lineWidth = lineWidth * 3
                            end
                          end
                        }%
                        %{ for i = 0, nbWayPoint - 1 do }%
                          %{ local offset = width * (j / numberOfLanes - 0.5) }%
                          %{= wayPoints[i+1].x + math.cos(angle[i]) * (offset - lineWidth) }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * (offset - lineWidth) + heightOffset }% %{= wayPoints[i+1].z + math.sin(angle[i]) * (offset - lineWidth) }%
                          %{= wayPoints[i+1].x + math.cos(angle[i]) * (offset + lineWidth) }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * (offset + lineWidth) + heightOffset }% %{= wayPoints[i+1].z + math.sin(angle[i]) * (offset + lineWidth) }%
                        %{ end }%
                      ]
                    }
                    texCoord TextureCoordinate {
                      point [
                        %{ for i = 0, nbWayPoint - 1 do }%
                          %{= 0 }% %{= distance[i] }%
                          %{ if roadLines[j] and roadLines[j].fields.type.value == "double" then }%
                            %{= 2 }% %{= distance[i] }%
                          %{ else }%
                            %{= 1 }% %{= distance[i] }%
                          %{ end }%
                        %{ end }%
                      ]
                    }
                    coordIndex [
                      %{ for i = 0, nbWayPoint - 2 do }%
                        %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                      %{ end }%
                    ]
                    texCoordIndex [
                      %{ for i = 0, nbWayPoint - 2 do }%
                        %{= 2 * i }% %{= 2 * (i + 1) }% %{= 1 + 2 * (i + 1) }% %{= 1 + 2 * i }% -1
                      %{ end }%
                    ]
                    creaseAngle 0.2
                  }
                  castShadows IS castShadows
                }
              ]
              name "road line(%{= j - 1 }%)"
              recognitionColors [ 1 1 1 ]
              model "road line"
            }
          %{ end }%
        %{ end }%
      %{ end }%
      # right border
      %{ if rightBorder then }%
        DEF RIGHT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF RIGHT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= -(width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2  }%   %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # lower exterior right street border
                        %{= -(width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # higher exterior right street border
                      %{ end }%
                      %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # higher interior right street border
                      %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }%   %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # lower interior right street border
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= distance[i] }% %{= 2 * borderHeight + borderWidth[i+1] }%
                        %{= distance[i] }% %{= borderHeight + borderWidth[i+1] }%
                      %{ end }%
                      %{= distance[i] }% %{= borderHeight }%
                      %{= distance[i] }% 0
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{
                    local skip = 2
                    if nbBorderWidthPoint > 0 then
                      skip = 4
                    end
                  }%
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road right border"
          %{ if rightBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE RIGHT_BORDER_GEOMETRY
          %{ end }%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %{ end }%
      # left border
      %{ if leftBorder then }%
        DEF LEFT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF LEFT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if leftBorder then }%
                        %{=  width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # lower interior left street border
                        %{=  width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }% # higher interior left street border
                        %{ if nbBorderWidthPoint > 0 then }%
                          %{= (width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= borderHeight + wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # higher exterior left street border
                          %{= (width/2 + borderWidth[i+1])  * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }%   %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }% # lower exterior left street border
                        %{ end }%
                      %{ end }%
                    %{ end }%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %{ for i = 0, nbWayPoint - 1 do }%
                      %{ if nbBorderWidthPoint > 0 then }%
                        %{= distance[i] }% %{= 2 * borderHeight + borderWidth[i+1] }%
                        %{= distance[i] }% %{= borderHeight + borderWidth[i+1] }%
                      %{ end }%
                      %{= distance[i] }% %{= borderHeight }%
                      %{= distance[i] }% 0
                    %{ end }%
                  ]
                }
                coordIndex [
                  %{
                    if nbBorderWidthPoint > 0 then
                      skip = 4
                    else
                      skip = 2
                    end
                  }%
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                texCoordIndex [
                  %{ for i = 0, nbWayPoint - 2 do }%
                    %{ for j = 0, skip - 2 do }%
                      %{= j + skip * i }% %{= j + skip * (i + 1) }% %{= 1 + j + skip * (i + 1) }% %{= 1 + j + skip * i }% -1
                    %{ end }%
                  %{ end }%
                  # close at the start and end
                  %{ if nbBorderWidthPoint > 0 then }%
                    # start
                    0 1 2 3 -1
                    # end
                    %{= nbWayPoint * 4 - 1 }% %{= nbWayPoint * 4 - 2 }% %{= nbWayPoint * 4 - 3 }% %{= nbWayPoint * 4 - 4 }% -1
                  %{ end }%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road left border"
          %{ if leftBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE LEFT_BORDER_GEOMETRY
          %{ end }%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %{ end }%
      # handle the special bridge case
      %{ if rightBorder and leftBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then }%
        Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF START_END_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %{=  width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= wayPoints[1].y + math.sin(tilt[1]) * width / 2 }%                  %{=  width/2 * math.sin(angle[0]) + wayPoints[1].z }% # lower interior left street border (start)
                    %{=  width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= borderHeight + wayPoints[1].y + math.sin(tilt[1]) * width / 2 }%   %{=  width/2 * math.sin(angle[0]) + wayPoints[1].z }% # higher interior left street border (start)
                    %{= -width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= borderHeight + wayPoints[1].y - math.sin(tilt[1]) * width / 2 }%   %{= -width/2 * math.sin(angle[0]) + wayPoints[1].z }% # higher interior right street border (start)
                    %{= -width/2 * math.cos(angle[0]) + wayPoints[1].x }% %{= wayPoints[1].y - math.sin(tilt[1]) * width / 2 }%                  %{= -width/2 * math.sin(angle[0]) + wayPoints[1].z }% # lower interior right street border (start)
                    %{=  width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y + math.sin(tilt[nbWayPoint]) * width / 2 }%                  %{=  width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # lower interior left street border (end)
                    %{=  width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= borderHeight + wayPoints[nbWayPoint].y + math.sin(tilt[nbWayPoint]) * width / 2 }%   %{=  width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # higher interior left street border (end)
                    %{= -width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= borderHeight + wayPoints[nbWayPoint].y - math.sin(tilt[nbWayPoint]) * width / 2 }%   %{= -width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # higher interior right street border (end)
                    %{= -width/2 * math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y - math.sin(tilt[nbWayPoint]) * width / 2 }%                  %{= -width/2 * math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint].z }% # lower interior right street border (end)
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0                0
                    0            %{= borderHeight }%
                    %{= width }% %{= borderHeight }%
                    %{= width }%     0
                    0                0
                    0            %{= borderHeight }%
                    %{= width }% %{= borderHeight }%
                    %{= width }%     0
                  ]
                }
                coordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                texCoordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          %{ if rightBorderBO and leftBorderBO then }%
            contactMaterial IS contactMaterial
            boundingObject USE START_END_BORDER_GEOMETRY
          %{ end }%
        }
      %{ end }%
      %{ if rightBarrier then }%
        CrashBarrier {
          name "right crash barrier"
          subdivision -1
          enableBoundingObject IS rightBarrierBoundingObject
          barrierOnRightSide FALSE
          path [
          %{ for i = 0, nbWayPoint - 1 do }%
            %{= -(width / 2 + barrierOffset) * math.cos(angle[i]) + wayPoints[i + 1].x }% %{= wayPoints[i + 1].y - math.sin(tilt[i + 1]) * (width / 2 + barrierOffset) }% %{= -(width / 2 + barrierOffset) * math.sin(angle[i]) + wayPoints[i + 1].z }%
          %{ end }%
          ]
        }
      %{ end }%
      %{ if leftBarrier then }%
        CrashBarrier {
          name "left crash barrier"
          subdivision -1
          enableBoundingObject IS leftBarrierBoundingObject
          barrierOnRightSide TRUE
          path [
          %{ for i = 0, nbWayPoint - 1 do }%
            %{= (width / 2 + barrierOffset) * math.cos(angle[i]) + wayPoints[i + 1].x }% %{= wayPoints[i + 1].y + math.sin(tilt[i + 1]) * (width / 2 + barrierOffset) }% %{= (width / 2 + barrierOffset) * math.sin(angle[i]) + wayPoints[i + 1].z }%
          %{ end }%
          ]
        }
      %{ end }%
      # bottom
      %{ if bottom then }%
        Shape {
          appearance PBRAppearance {
            baseColorMap ImageTexture {
              url IS bottomTexture
              filtering 5
            }
            roughness 0.8
            metalness 0
          }
          geometry DEF BOTTOM_GEOMETRY IndexedFaceSet {
            coord Coordinate {
              point [
                %{
                  local leftHeightOffset = 0.0
                  local rightHeightOffset = 0.0
                  if leftBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then
                    leftHeightOffset = borderHeight
                  end
                  if rightBorder and nbBorderWidthPoint == 0 and borderHeight < 0 then
                    rightHeightOffset = borderHeight
                  end
                }%
                %{ for i = 0, nbWayPoint - 1 do }%
                  %{ if leftBorder and nbBorderWidthPoint > 0 then }%
                    %{= (width/2 + borderWidth[i+1]) * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 }% %{= (width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ else }%
                    %{= width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y + math.sin(tilt[i+1]) * width / 2 + leftHeightOffset }% %{= width/2 * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ end }%
                  %{ if rightBorder and nbBorderWidthPoint > 0 then }%
                    %{= -(width/2 + borderWidth[i+1]) * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 }% %{= -(width/2 + borderWidth[i+1]) * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ else }%
                    %{= -width/2 * math.cos(angle[i]) + wayPoints[i+1].x }% %{= wayPoints[i+1].y - math.sin(tilt[i+1]) * width / 2 + rightHeightOffset }% %{= -width/2 * math.sin(angle[i]) + wayPoints[i+1].z }%
                  %{ end }%
                %{ end }%
              ]
            }
            %{ if useBottomTexture then }%
              texCoord TextureCoordinate {
                point [
                  %{ for i = 0, nbWayPoint - 1 do }%
                    %{
                      local bottomWidth = width
                      if leftBorder and nbBorderWidthPoint > 0 then
                        bottomWidth = bottomWidth + borderWidth[i+1]
                      end
                      if rightBorder and nbBorderWidthPoint > 0 then
                        bottomWidth = bottomWidth + borderWidth[i+1]
                      end
                    }%
                    %{= distance[i] }%     0
                    %{= distance[i] }% %{= bottomWidth }%
                  %{ end }%
                ]
              }
            %{ end }%
            coordIndex [
              %{  skip = 2 }%
              %{ for i = 0, nbWayPoint - 2 do }%
                %{= skip * i }% %{= skip * (i + 1) }% %{= 1 + skip * (i + 1) }% %{= 1 + skip * i }% -1
              %{ end }%
            ]
            %{ if useBottomTexture then }%
              texCoordIndex [
                %{  skip = 2 }%
                %{ for i = 0, nbWayPoint - 2 do }%
                  %{= skip * i }% %{= skip * (i + 1) }% %{= 1 + skip * (i + 1) }% %{= 1 + skip * i }% -1
                %{ end }%
              ]
            %{ end }%
            creaseAngle 0.2
          }
          castShadows IS castShadows
        }
      %{ end }%
      # turn lanes (forward)
      %{ if nbWayPoint > 2 and fields.turnLanesForward.value ~= '' then }%
        Transform {
          translation %{= wayPoints[nbWayPoint].x }% %{= wayPoints[nbWayPoint].y + heightOffset }% %{= wayPoints[nbWayPoint].z }%
          rotation 0 1 0 %{= math.pi - angle[nbWayPoint - 1] }%
          children [
          %{
            local turnLanes = wbstring.split(fields.turnLanesForward.value, '|')
            local nTurnLanes = wbcore.tablelength(turnLanes)
          }%
          %{ for i,turnLane in ipairs(turnLanes) do }%
            Transform {
              translation %{= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width }% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %{
                        local through = string.match(turnLane, "through")
                        local left = string.match(turnLane, "left")
                        local right = string.match(turnLane, "right")

                        local trX = 0
                        if left then
                          trX = trX + 1
                        end
                        if right then
                          trX = trX + 2
                        end
                        local trY = through and 1 or 0
                      }%
                      scale 0.25 0.5
                      translation %{= trX }% %{= trY }%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %{ end }%
          ]
        }
      %{ end }%
      # turn lanes (backward)
      %{ if nbWayPoint > 2 and fields.turnLanesBackward.value ~= '' then }%
        Transform {
          translation %{= wayPoints[1].x }% %{= wayPoints[1].y + heightOffset }% %{= wayPoints[1].z }%
          rotation 0 1 0 %{= - angle[2] }%
          children [
          %{
            local turnLanes = wbstring.split(fields.turnLanesBackward.value, '|')
            local nTurnLanes = wbcore.tablelength(turnLanes)
          }%
          %{ for i,turnLane in ipairs(turnLanes) do }%
            Transform {
              translation %{= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width }% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %{
                        local through = string.match(turnLane, "through")
                        local left = string.match(turnLane, "left")
                        local right = string.match(turnLane, "right")

                        local trX = 0
                        if left then
                          trX = trX + 1
                        end
                        if right then
                          trX = trX + 2
                        end
                        local trY = through and 1 or 0
                      }%
                      scale 0.25 0.5
                      translation %{= trX }% %{= trY }%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %{ end }%
          ]
        }
      %{ end }%
    ]
    locked IS locked
  }
}
