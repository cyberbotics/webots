#VRML_SIM R2022a utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# A fully customizable road, the number of lanes, the dimensions and the path of the road is configurable.
# For each line separating two lanes it is possible to configure if this one is continuous or dashed.
# B-Spline can be used in order to interpolate the path of the road and an optional border can be enable.
# The boundingObject of each border and the road itself can be independently enable or disable.
# This model was sponsored by the CTI project RO2IVSim (http://transport.epfl.ch/simulator-for-mobile-robots-and-intelligent-vehicles).
# template language: javascript

PROTO Road [
  field        SFVec3f              translation               0 0 0
  field        SFRotation           rotation                  0 0 1 0
  field        SFString             name                      "road"                  # Optionally defines the street name.
  field        SFString             id                        ""                      # Optionally defines a unique ID. A unique ID is required to use the SUMO exporter.
  field        SFString             startJunction             ""                      # Optionally defines a reference to the Crossroad connected at the first Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFString             endJunction               ""                      # Optionally defines a reference to the Crossroad connected at the last Road waypoint. Setting correctly this field is required to use the SUMO exporter.
  field        SFFloat              width                     7                       # Defines the total width of the road (excluding sidewalk).
  field        SFInt32              numberOfLanes             2                       # Defines the number of lanes (used for the texture mapping).
  field        SFInt32              numberOfForwardLanes      1                       # Defines the number of forward lanes. (this is an information with no impact on the graphical shape).
  field        SFFloat              speedLimit                -1.0                    # Optionally defines the speed limit. The recommended unit is meter per seconds.
  field        MFNode{RoadLine {}}  lines                     [ RoadLine { } ]        # Defines the property of each line separating two lanes.
  field        SFFloat              roadBorderHeight          0.15                    # Defines the height of the sidewalk.
  field        MFFloat              roadBorderWidth           [ 0.8 ]                 # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               road                      TRUE                    # Defines the width of the sidewalk associated to each way-point (if there are less values than way-points, the last value is used for the last remaining way-points).
  field        SFBool               rightBorder               TRUE                    # Defines whether the road should have a right sidewalk.
  field        SFBool               leftBorder                TRUE                    # Defines whether the road should have a left sidewalk.
  field        SFBool               rightBarrier              FALSE                   # Defines whether the road should have a right barrier.
  field        SFBool               leftBarrier               FALSE                   # Defines whether the road should have a left barrier.
  field        SFBool               bottom                    FALSE                   # Defines whether the road bottom should be displayed (useful in case of bridge).
  field        MFVec3f              wayPoints                 [ 0 0 0, 1 0 0 ]        # Defines the path of the road.
  field        MFFloat              roadTilt                  [ 0, 0]                 # Defines the tilting angle corresponding to each way-point (if there are less values than way-points, 0 is used for the last remaining way-points).
  field        MFFloat              startingAngle             []                      # Optionally defines the angle of the road at the first way-point.
  field        MFFloat              endingAngle               []                      # Optionally defines the angle of the road at the lasst way-point.
  field        MFString             startLine                 []                      # Optionally defines the texture used for the road line at the first way-point for each lane. If the string is empty, no road line will be added for the corresponding lane. The two textures `textures/road_line_dashed.png` and `textures/road_line_triangle.png` may be used in this field.
  field        MFString             endLine                   []                      # Optionally defines the texture used for the road line at the last way-point for each lane. If the string is empty, no road line will be added for the corresponding lane.
  field        SFInt32              splineSubdivision         4                       # Defines the degree of interpolation using B-Splines (if the value is lower than 0, the interpolation is disabled).
  field        SFNode               appearance                Asphalt { }             # Defines the appearance of the road.
  field        SFNode               pavementAppearance        Pavement { }            # Defines the appearance of the sidewalk.
  field        MFString             bottomTexture             []                      # Defines the texture to be used for the bottom of the road.
  field        SFString             turnLanesForward          ""                      # Defines painted arrows before the end of the lanes using the same format as the OSM "turn:lanes:forward" key (e.g. "through|left;through|none"). Please refer to the corresponding OSM tag: http://wiki.openstreetmap.org/wiki/Key:turn.
  field        SFString             turnLanesBackward         ""                      # Same as `turnLanesForward` but for the OSM "turn:lanes:backward" key.
  field        SFBool               locked                    TRUE                    # Is `Solid.locked`.
  field        SFBool               roadBoundingObject        FALSE                   # Defines whether the road should have a bounding object.
  field        SFBool               rightBorderBoundingObject FALSE                   # Defines whether the right sidewalk should have a bounding object.
  field        SFBool               leftBorderBoundingObject  FALSE                   # Defines whether the left sidewalk should have a bounding object.
  field        SFBool               rightBarrierBoundingObject TRUE                   # Defines whether the right crash barrier (if any) should have a bounding object.
  field        SFBool               leftBarrierBoundingObject TRUE                    # Defines whether the left crash barrier (if any) should have a bounding object.
  field        SFBool               castShadows               FALSE                   # Defines whether the road should cast shadows.
  field        SFString             contactMaterial           "default"               # Is `Solid.contactMaterial`.
]
{
  %<
    import * as wbgeometry from 'wbgeometry.js';
    import * as wbvector2 from 'wbvector2.js';
    import * as wbvector3 from 'wbvector3.js';

    // fields checks
    let width = fields.width.value;
    if (width <= 0.0) {
      width = fields.width.defaultValue;
      console.error('\'width\' must be strictly positive. Value reset to ' + width + '.');
    }
    const halfWidth = width * 0.5;

    const barrierOffset = 0.06 + 0.05 * width;
    let numberOfLanes = fields.numberOfLanes.value;
    if (numberOfLanes < 1) {
      numberOfLanes = fields.numberOfLanes.defaultValue;
      console.error('\'numberOfLanes\' must be greater or equal to 1. Value reset to ' + numberOfLanes + '.');
    }
    let borderHeight = fields.roadBorderHeight.value;
    let borderWidth = fields.roadBorderWidth.value;
    const nbBorderWidthPoint = borderWidth.length;

    for (let j = 0; j < nbBorderWidthPoint; ++j) {
      if (borderWidth[j] < 0) {
        borderWidth[j] = 0;
        console.error('\'roadBorderWidth\' elements must be positive. Value reset to ' + borderWidth[j] + '.');
      }
    }

    let roadLines = fields.lines.value;
    for (let i = 0; i < roadLines.length; ++i) {
      if (roadLines[i].node_name !== 'RoadLine') {
        roadLines[i] = undefined;
        console.error('Only \'RoadLine\' nodes should be added in the \'lines\' field.');
      }
    }

    let textureCoordinateRatio = 0.2;
    let defaultLineWidth = 0.075;
    let heightOffset  = 0.01;
    const rightBorder   = fields.rightBorder.value;
    const leftBorder    = fields.leftBorder.value;
    const rightBarrier  = fields.rightBarrier.value;
    const leftBarrier   = fields.leftBarrier.value;
    const bottom        = fields.bottom.value;
    const road          = fields.road.value;
    const roadBO        = fields.roadBoundingObject.value;
    const rightBorderBO = fields.rightBorderBoundingObject.value;
    const leftBorderBO  = fields.leftBorderBoundingObject.value;
    const startingAngle = fields.startingAngle.value;
    const endingAngle   = fields.endingAngle.value;
    const startLine     = fields.startLine.value;
    const endLine       = fields.endLine.value;
    const bottomTexture = fields.bottomTexture.value;
    let useBottomTexture = false;
    if (bottomTexture.length > 0)
      useBottomTexture = true;

    const nbStartLine = startLine.length > numberOfLanes ? numberOfLanes : startLine.length;
    const nbEndLine   = endLine.length > numberOfLanes ? numberOfLanes : endLine.length;

    let wayPoints = fields.wayPoints.value;
    let nbWayPoint = wayPoints.length;

    let borderWidthOriginal = [];
    if (nbBorderWidthPoint > 0)
      for (let j = 0; j < nbWayPoint + 1; ++j) {
        if (borderWidth[j] === undefined)
          borderWidthOriginal[j] = borderWidthOriginal[j - 1];
        else
          borderWidthOriginal[j] = borderWidth[j];
      }

    let originalTilt = fields.roadTilt.value;
    for (let j = 0; j < nbWayPoint; ++j)
      if (originalTilt[j] === undefined)
        originalTilt[j] = 0;

    originalTilt[nbWayPoint] = originalTilt[nbWayPoint - 1];

    let splineSubdivision = fields.splineSubdivision.value;
    // use B-Spline interpolation if splineSubdivision is greater than 1
    if (splineSubdivision > 0)
      wayPoints = wbgeometry.bSpline3(wayPoints, splineSubdivision);

    nbWayPoint = wayPoints.length;

    let tilt = [];
    if (splineSubdivision > 1)
      for (let j = 0; j < nbWayPoint; ++j) {
        let ratio = (j % splineSubdivision) / splineSubdivision;
        let index = Math.floor(j/splineSubdivision);
        tilt[j] = originalTilt[index] * (1 - ratio) + originalTilt[index + 1] * ratio;
        if (nbBorderWidthPoint > 0)
          borderWidth[j] = borderWidthOriginal[index] * (1 - ratio) + borderWidthOriginal[index + 1] * ratio;
      }
    else {
      if (nbBorderWidthPoint > 0)
        borderWidth = borderWidthOriginal;

      tilt = originalTilt;
    }

    let angle = []
    let distance = [0];
    for (let i = 0; i <= nbWayPoint - 1; ++i) {
      // compute angle for each way-point
      if ((i === nbWayPoint - 1 || i >= (nbWayPoint - 1 - splineSubdivision)) && endingAngle[0] !== undefined) {
        // last segment with ending angle set
        // we use third order Spline approximation,
        // therefore we want to adapt the angle of the road with a cubic ratio between last and second last way-points
        let ratio = 0;
        if (splineSubdivision > 0)
          ratio = Math.pow(((nbWayPoint - 1 - i)  / splineSubdivision), 3);

        if (i === 0)
          angle[i] = endingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].y}, {x: wayPoints[i].x, y: wayPoints[i].y}) * ratio;
        else
          angle[i] = endingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i].x, y: wayPoints[i].y}, {x: wayPoints[i-1].x, y: wayPoints[i-1].y}) * ratio;
      } else if (i > 0 && i > splineSubdivision) {
        // all the segments except first
        if (i === nbWayPoint - 1)
          angle[i] = -wbvector2.angle({x: wayPoints[i].x, y: wayPoints[i].y}, {x: wayPoints[i-1].x, y: wayPoints[i-1].y});
        else
          angle[i] = -wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].y}, {x: wayPoints[i-1].x, y: wayPoints[i-1].y});
      } else if (startingAngle[0] !== undefined) {
        // first segment with starting angle set
        let ratio = 0;
        if (splineSubdivision > 0)
          ratio = Math.pow((i / splineSubdivision), 3);

        if (i === nbWayPoint - 1)
          angle[i] = startingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i].x, y: wayPoints[i].y}, {x: wayPoints[i-1].x, y: wayPoints[i-1].y}) * ratio;
        else
          angle[i] = startingAngle[0] * (1 - ratio) - wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].y}, {x: wayPoints[i].x, y: wayPoints[i].y}) * ratio;
      } else {
        // first segment if starting angle is not set
        if (i === nbWayPoint - 1)
          angle[i] = -wbvector2.angle({x: wayPoints[i].x, y: wayPoints[i].y}, {x: wayPoints[i-1].x, y: wayPoints[i-1].y});
        else
          angle[i] = -wbvector2.angle({x: wayPoints[i+1].x, y: wayPoints[i+1].y }, {x: wayPoints[i].x, y: wayPoints[i].y});
      }

      // compute distance (from beginning of road) for each way-points
      if (i !== 0)
        distance[i] = distance[i-1] + wbvector3.distance(wayPoints[i], wayPoints[i-1]);
    }
  >%
  Solid {
    translation IS translation
    rotation IS rotation
    name IS name
    model "road"
    children [
      Group {
        children IS lines
      }
      # road
      %< if (road) { >%
        DEF ROAD Solid {
          children [
            Shape {
              appearance IS appearance
              geometry DEF ROAD_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %<= wayPoints[i].x - 0.5 * Math.sin(angle[i]) * width >% %<= wayPoints[i].y - 0.5 * Math.cos(angle[i]) * width >% %<= wayPoints[i].z - 0.5 * Math.sin(tilt[i]) * width >%
                      %<= wayPoints[i].x + 0.5 * Math.sin(angle[i]) * width >% %<= wayPoints[i].y + 0.5 * Math.cos(angle[i]) * width >% %<= wayPoints[i].z + 0.5 * Math.sin(tilt[i]) * width >%
                    %< } >%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %<= -0.5 * width * textureCoordinateRatio >% %<= distance[i] * textureCoordinateRatio >%
                      %<= 0.5 * width * textureCoordinateRatio >% %<= distance[i] * textureCoordinateRatio >%
                    %< } >%
                  ]
                }
                coordIndex [
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %<= 2 * i >% %<= 2 * (i + 1) >% %<= 1 + 2 * (i + 1) >% -1
                    %<= 2 * i >% %<= 1 + 2 * (i + 1) >% %<= 1 + 2 * i >% -1
                  %< } >%
                ]
                texCoordIndex [
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %<= 2 * i >% %<= 2 * (i + 1) >% %<= 1 + 2 * (i + 1) >% -1
                    %<= 2 * i >% %<= 1 + 2 * (i + 1) >% %<= 1 + 2 * i >% -1
                  %< } >%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road ground"
          %< if (roadBO) { >%
            contactMaterial IS contactMaterial
            boundingObject USE ROAD_GEOMETRY
          %< } >%
          recognitionColors [ 0.2 0.2 0.2 ]
          model "road"
        }
        # road signs (start)
        %<
          for (let i = 0; i <= nbStartLine - 1; ++i) {
            if (startLine[i+1] !== startLine[i] && startLine[i+1] !== '') {
              let size = 1;
              for (let j = i + 1; j <= nbStartLine - 1; ++j) {
                if (startLine[i+1] === startLine[j+1])
                  size = size + 1;
                else
                  break;
              }
        >%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %<= '"' + startLine[i] + '"' >% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "webots://projects/objects/road/protos/textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "webots://projects/objects/road/protos/textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF START_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %< let heightDiff = 0.4 * (wayPoints[1].z - wayPoints[0].z) /  wbvector2.distance({x: wayPoints[0].y, y: wayPoints[0].x }, {x: wayPoints[1].y, y: wayPoints[1].x }); >%
                    %<= (i / numberOfLanes - 0.5)          * Math.sin(angle[0]) * width + wayPoints[0].x >% %<= (i / numberOfLanes - 0.5)          * Math.cos(angle[0]) * width + wayPoints[0].y >%                             %<= wayPoints[0].z + (i / numberOfLanes - 0.5)          * Math.sin(tilt[0]) * width + heightOffset >%
                    %<= ((i + size) / numberOfLanes - 0.5) * Math.sin(angle[0]) * width + wayPoints[0].x >% %<= ((i + size) / numberOfLanes - 0.5) * Math.cos(angle[0]) * width + wayPoints[0].y >%                             %<= wayPoints[0].z + ((i + size) / numberOfLanes - 0.5) * Math.sin(tilt[0]) * width + heightOffset >%
                    %<= ((i + size) / numberOfLanes - 0.5) * Math.sin(angle[0]) * width + wayPoints[0].x + 0.4 * Math.cos(angle[0]) >% %<= ((i + size) / numberOfLanes - 0.5) * Math.cos(angle[0]) * width + wayPoints[0].y + 0.4 * Math.sin(-angle[0]) >% %<= wayPoints[0].z + ((i + size) / numberOfLanes - 0.5) * Math.sin(tilt[0]) * width + heightOffset + heightDiff >%
                    %<= (i / numberOfLanes - 0.5)          * Math.sin(angle[0]) * width + wayPoints[0].x + 0.4 * Math.cos(angle[0]) >% %<= (i / numberOfLanes - 0.5)          * Math.cos(angle[0]) * width + wayPoints[0].y + 0.4 * Math.sin(-angle[0]) >% %<= wayPoints[0].z + (i / numberOfLanes - 0.5)          * Math.sin(tilt[0]) * width + heightOffset + heightDiff >%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %<= size * width / (0.4 * numberOfLanes) >% 0
                    %<= size * width / (0.4 * numberOfLanes) >% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 3 2 1
                ]
                texCoordIndex [
                  0 3 2 1
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %< } >%
        %< } >%
        # road signs (end)
        %<
          for (let i = 0; i <= nbEndLine - 1; ++i) {
            if (endLine[i+1] !== endLine[i] && endLine[i+1] !== '') {
              let size = 1;
              for (let j = i + 1; j <= nbEndLine - 1; ++j) {
                if (endLine[i+1] === endLine[j+1])
                  size = size + 1;
                else
                  break;
              }
        >%
            Shape {
              appearance PBRAppearance {
                baseColorMap ImageTexture {
                  url [ %<= '"' + endLine[i] + '"' >% ]
                  filtering 5
                }
                roughness 0.7
                metalness 0
                normalMap ImageTexture {
                  url [
                    "webots://projects/objects/road/protos/textures/line_normal.jpg"
                  ]
                  filtering 5
                }
                occlusionMap ImageTexture {
                  url [
                    "webots://projects/objects/road/protos/textures/line_occlusion.jpg"
                  ]
                  filtering 5
                }
              }
              geometry DEF END_ROAD_LINES_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %< let heightDiff = 0.4 * (wayPoints[nbWayPoint-2].z - wayPoints[nbWayPoint-1].z) /  wbvector2.distance({x: wayPoints[nbWayPoint-2].y, y: wayPoints[nbWayPoint-2].x}, {x: wayPoints[nbWayPoint-1].y, y: wayPoints[nbWayPoint-1].x }); >%
                    %<= (i / numberOfLanes - 0.5)          * Math.sin(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].x >%                                       %<= (i / numberOfLanes - 0.5)          * Math.cos(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].y >%                                        %<= wayPoints[nbWayPoint-1].z + (i / numberOfLanes - 0.5)          * Math.sin(tilt[nbWayPoint-1]) * width + heightOffset >%
                    %<= ((i + size) / numberOfLanes - 0.5) * Math.sin(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].x >%                                       %<= ((i + size) / numberOfLanes - 0.5) * Math.cos(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].y >%                                        %<= wayPoints[nbWayPoint-1].z + ((i + size) / numberOfLanes - 0.5) * Math.sin(tilt[nbWayPoint-1]) * width + heightOffset >%
                    %<= ((i + size) / numberOfLanes - 0.5) * Math.sin(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].x - 0.4 * Math.cos(angle[nbWayPoint-2]) >% %<= ((i + size) / numberOfLanes - 0.5) * Math.cos(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].y - 0.4 * Math.sin(-angle[nbWayPoint-2]) >% %<= wayPoints[nbWayPoint-1].z + ((i + size) / numberOfLanes - 0.5) * Math.sin(tilt[nbWayPoint-1]) * width + heightOffset + heightDiff >%
                    %<= (i / numberOfLanes - 0.5)          * Math.sin(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].x - 0.4 * Math.cos(angle[nbWayPoint-2]) >% %<= (i / numberOfLanes - 0.5)          * Math.cos(angle[nbWayPoint-2]) * width + wayPoints[nbWayPoint-1].y - 0.4 * Math.sin(-angle[nbWayPoint-2]) >% %<= wayPoints[nbWayPoint-1].z + (i / numberOfLanes - 0.5)          * Math.sin(tilt[nbWayPoint-1]) * width + heightOffset + heightDiff >%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0 0
                    %<= size * width / (0.4 * numberOfLanes) >% 0
                    %<= size * width / (0.4 * numberOfLanes) >% 1
                    0 1
                  ]
                }
                coordIndex [
                  0 1 2 3
                ]
                texCoordIndex [
                  0 1 2 3
                ]
                creaseAngle 0.2
              }
              castShadows FALSE
            }
          %< } >%
        %< } >%
        # lines
        %< for (let j = 0; j < numberOfLanes - 1; ++j) { >%
          %< if (typeof roadLines[j] === 'undefined' || (roadLines[j].fields.type.value !== 'none' && roadLines[j].fields.width.value > 0)) { >%
            DEF LINES Solid {
              children [
                Shape {
                  appearance PBRAppearance {
                    %< if (typeof roadLines[j] !== 'undefined') { >%
                      baseColor %<= roadLines[j].fields.color.value.r >% %<= roadLines[j].fields.color.value.g >% %<= roadLines[j].fields.color.value.b >%
                    %< } >%
                    baseColorMap ImageTexture {
                      url [
                      %< if (typeof roadLines[j] !== 'undefined' && (roadLines[j].fields.type.value === 'continuous' || roadLines[j].fields.type.value === 'double')) { >%
                        "webots://projects/objects/road/protos/textures/line_base_color.png"
                      %< } else { >%
                        "webots://projects/objects/road/protos/textures/line_base_color_dashed.png"
                      %< } >%
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      scale 1 0.2
                    }
                  }
                  geometry IndexedFaceSet {
                    coord Coordinate {
                      point [
                        %<
                          let lineWidth = defaultLineWidth;
                          if (typeof roadLines[j] !== 'undefined') {
                            lineWidth = roadLines[j].fields.width.value * 0.5;
                            if (roadLines[j].fields.type.value === 'double')
                              lineWidth = lineWidth * 3;
                          }
                        >%
                        %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                          %< let offset = width * ((j+1) / numberOfLanes - 0.5); >%
                          %<= wayPoints[i].x + Math.sin(angle[i]) * (offset - lineWidth) >% %<= wayPoints[i].y + Math.cos(angle[i]) * (offset - lineWidth) >% %<= wayPoints[i].z + Math.sin(tilt[i]) * (offset - lineWidth) + heightOffset >%
                          %<= wayPoints[i].x + Math.sin(angle[i]) * (offset + lineWidth) >% %<= wayPoints[i].y + Math.cos(angle[i]) * (offset + lineWidth) >% %<= wayPoints[i].z + Math.sin(tilt[i]) * (offset + lineWidth) + heightOffset >%
                        %< } >%
                      ]
                    }
                    texCoord TextureCoordinate {
                      point [
                        %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                          %<= 0 >% %<= distance[i] >%
                          %< if (typeof roadLines[j] !== 'undefined' && roadLines[j].fields.type.value === 'double') { >%
                            %<= 2 >% %<= distance[i] >%
                          %< } else { >%
                            %<= 1 >% %<= distance[i] >%
                          %< } >%
                        %< } >%
                      ]
                    }
                    coordIndex [
                      %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                        %<= 2 * i >% %<= 2 * (i + 1) >% %<= 1 + 2 * (i + 1) >% %<= 1 + 2 * i >% -1
                      %< } >%
                    ]
                    texCoordIndex [
                      %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                        %<= 2 * i >% %<= 2 * (i + 1) >% %<= 1 + 2 * (i + 1) >% %<= 1 + 2 * i >% -1
                      %< } >%
                    ]
                    creaseAngle 0.2
                  }
                  castShadows IS castShadows
                }
              ]
              name "road line(%<= j - 1 >%)"
              recognitionColors [ 1 1 1 ]
              model "road line"
            }
          %< } >%
        %< } >%
      %< } >%
      # right border
      %< if (rightBorder) { >%
        DEF RIGHT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF RIGHT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %< if (nbBorderWidthPoint > 0) { >%
                        %<= -(halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= -(halfWidth + borderWidth[i])  * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z - Math.sin(tilt[i]) * halfWidth  >% # lower exterior right street border
                        %<= -(halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= -(halfWidth + borderWidth[i])  * Math.cos(angle[i]) + wayPoints[i].y >% %<= borderHeight + wayPoints[i].z - Math.sin(tilt[i]) * halfWidth >% # higher exterior right street border
                      %< } >%
                      %<= -halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<= -halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= borderHeight + wayPoints[i].z - Math.sin(tilt[i]) * halfWidth >% # higher interior right street border
                      %<= -halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<= -halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z - Math.sin(tilt[i]) * halfWidth >% # lower interior right street border
                    %< } >%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %< if (nbBorderWidthPoint > 0) { >%
                        %<= distance[i] >% %<= 2 * borderHeight + borderWidth[i] >%
                        %<= distance[i] >% %<= borderHeight + borderWidth[i] >%
                      %< } >%
                      %<= distance[i] >% %<= borderHeight >%
                      %<= distance[i] >% 0
                    %< } >%
                  ]
                }
                coordIndex [
                  %<
                    let skip = 2;
                    if (nbBorderWidthPoint > 0)
                      skip = 4;
                  >%
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %< for (let j = 0; j <= skip - 2; ++j) { >%
                      %<= j + skip * i >% %<= j + skip * (i + 1) >% %<= 1 + j + skip * (i + 1) >% %<= 1 + j + skip * i >% -1
                    %< } >%
                  %< } >%
                  # close at the start and end
                  %< if (nbBorderWidthPoint > 0) { >%
                    # start
                    0 1 2 3 -1
                    # end
                    %<= nbWayPoint * 4 - 1 >% %<= nbWayPoint * 4 - 2 >% %<= nbWayPoint * 4 - 3 >% %<= nbWayPoint * 4 - 4 >% -1
                  %< } >%
                ]
                texCoordIndex [
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %< for (let j = 0; j <= skip - 2; ++j) { >%
                      %<= j + skip * i >% %<= j + skip * (i + 1) >% %<= 1 + j + skip * (i + 1) >% %<= 1 + j + skip * i >% -1
                    %< } >%
                  %< } >%
                  # close at the start and end
                  %< if (nbBorderWidthPoint > 0) { >%
                    # start
                    0 1 2 3 -1
                    # end
                    %<= nbWayPoint * 4 - 1 >% %<= nbWayPoint * 4 - 2 >% %<= nbWayPoint * 4 - 3 >% %<= nbWayPoint * 4 - 4 >% -1
                  %< } >%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road right border"
          %< if (rightBorderBO) { >%
            contactMaterial IS contactMaterial
            boundingObject USE RIGHT_BORDER_GEOMETRY
          %< } >%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %< } >%
      # left border
      %< if (leftBorder) { >%
        DEF LEFT_BORDER Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF LEFT_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %< if (leftBorder) { >%
                        %<= halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<=  halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z + Math.sin(tilt[i]) * halfWidth >% # lower interior left street border
                        %<= halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<=  halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= borderHeight + wayPoints[i].z + Math.sin(tilt[i]) * halfWidth >% # higher interior left street border
                        %< if (nbBorderWidthPoint > 0) { >%
                          %<= (halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= (halfWidth + borderWidth[i])  * Math.cos(angle[i]) + wayPoints[i].y >% %<= borderHeight + wayPoints[i].z + Math.sin(tilt[i]) * halfWidth >% # higher exterior left street border
                          %<= (halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= (halfWidth + borderWidth[i]) * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z + Math.sin(tilt[i]) * halfWidth >% # lower exterior left street border
                        %< } >%
                      %< } >%
                    %< } >%
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                      %< if (nbBorderWidthPoint > 0) { >%
                        %<= distance[i] >% %<= 2 * borderHeight + borderWidth[i] >%
                        %<= distance[i] >% %<= borderHeight + borderWidth[i] >%
                      %< } >%
                      %<= distance[i] >% %<= borderHeight >%
                      %<= distance[i] >% 0
                    %< } >%
                  ]
                }
                coordIndex [
                  %<
                    let skip;
                    if (nbBorderWidthPoint > 0)
                      skip = 4;
                    else
                      skip = 2;
                  >%
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %< for (let j = 0; j <= skip - 2; ++j) { >%
                      %<= j + skip * i >% %<= j + skip * (i + 1) >% %<= 1 + j + skip * (i + 1) >% %<= 1 + j + skip * i >% -1
                    %< } >%
                  %< } >%
                  # close at the start and end
                  %< if (nbBorderWidthPoint > 0) { >%
                    # start
                    0 1 2 3 -1
                    # end
                    %<= nbWayPoint * 4 - 1 >% %<= nbWayPoint * 4 - 2 >% %<= nbWayPoint * 4 - 3 >% %<= nbWayPoint * 4 - 4 >% -1
                  %< } >%
                ]
                texCoordIndex [
                  %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                    %< for (let j = 0; j <= skip - 2; ++j) { >%
                      %<= j + skip * i >% %<= j + skip * (i + 1) >% %<= 1 + j + skip * (i + 1) >% %<= 1 + j + skip * i >% -1
                    %< } >%
                  %< } >%
                  # close at the start and end
                  %< if (nbBorderWidthPoint > 0) { >%
                    # start
                    0 1 2 3 -1
                    # end
                    %<= nbWayPoint * 4 - 1 >% %<= nbWayPoint * 4 - 2 >% %<= nbWayPoint * 4 - 3 >% %<= nbWayPoint * 4 - 4 >% -1
                  %< } >%
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          name "road left border"
          %< if (leftBorderBO) { >%
            contactMaterial IS contactMaterial
            boundingObject USE LEFT_BORDER_GEOMETRY
          %< } >%
          recognitionColors [ 0.6 0.6 0.6 ]
          model "road border"
        }
      %< } >%
      # handle the special bridge case
      %< if (rightBorder && leftBorder && nbBorderWidthPoint === 0 && borderHeight < 0) { >%
        Solid {
          children [
            Shape {
              appearance IS pavementAppearance
              geometry DEF START_END_BORDER_GEOMETRY IndexedFaceSet {
                coord Coordinate {
                  point [
                    %<=  halfWidth * Math.sin(angle[0]) + wayPoints[0].x >% %<=  halfWidth * Math.cos(angle[0]) + wayPoints[0].y >% %<= wayPoints[0].z + Math.sin(tilt[0]) * halfWidth >%                # lower interior left street border (start)
                    %<=  halfWidth * Math.sin(angle[0]) + wayPoints[0].x >% %<=  halfWidth * Math.cos(angle[0]) + wayPoints[0].y >% %<= borderHeight + wayPoints[0].z + Math.sin(tilt[0]) * halfWidth >% # higher interior left street border (start)
                    %<= -halfWidth * Math.sin(angle[0]) + wayPoints[0].x >% %<= -halfWidth * Math.cos(angle[0]) + wayPoints[0].y >% %<= borderHeight + wayPoints[0].z - Math.sin(tilt[0]) * halfWidth >% # higher interior right street border (start)
                    %<= -halfWidth * Math.sin(angle[0]) + wayPoints[0].x >% %<= -halfWidth * Math.cos(angle[0]) + wayPoints[0].y >% %<= wayPoints[0].z - Math.sin(tilt[0]) * halfWidth >%                # lower interior right street border (start)
                    %<=  halfWidth * Math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].x >% %<=  halfWidth * Math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].y >% %<= wayPoints[nbWayPoint-1].z + Math.sin(tilt[nbWayPoint-1]) * halfWidth >%                # lower interior left street border (end)
                    %<=  halfWidth * Math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].x >% %<=  halfWidth * Math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].y >% %<= borderHeight + wayPoints[nbWayPoint-1].z + Math.sin(tilt[nbWayPoint-1]) * halfWidth >% # higher interior left street border (end)
                    %<= -halfWidth * Math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].x >% %<= -halfWidth * Math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].y >% %<= borderHeight + wayPoints[nbWayPoint-1].z - Math.sin(tilt[nbWayPoint-1]) * halfWidth >% # higher interior right street border (end)
                    %<= -halfWidth * Math.sin(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].x >% %<= -halfWidth * Math.cos(angle[nbWayPoint-1]) + wayPoints[nbWayPoint-1].y >% %<= wayPoints[nbWayPoint-1].z - Math.sin(tilt[nbWayPoint-1]) * halfWidth >%                # lower interior right street border (end)
                  ]
                }
                texCoord TextureCoordinate {
                  point [
                    0                0
                    0            %<= borderHeight >%
                    %<= width >% %<= borderHeight >%
                    %<= width >%     0
                    0                0
                    0            %<= borderHeight >%
                    %<= width >% %<= borderHeight >%
                    %<= width >%     0
                  ]
                }
                coordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                texCoordIndex [
                  0 1 2 3 -1
                  7 6 5 4 -1
                ]
                creaseAngle 0.2
              }
              castShadows IS castShadows
            }
          ]
          %< if (rightBorderBO && leftBorderBO) { >%
            contactMaterial IS contactMaterial
            boundingObject USE START_END_BORDER_GEOMETRY
          %< } >%
        }
      %< } >%
      %< if (rightBarrier) { >%
        CrashBarrier {
          name "right crash barrier"
          subdivision -1
          enableBoundingObject IS rightBarrierBoundingObject
          barrierOnRightSide FALSE
          path [
          %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
            %<= -(halfWidth + barrierOffset) * Math.sin(angle[i]) + wayPoints[i].x >% %<= -(halfWidth + barrierOffset) * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z - Math.sin(tilt[i]) * (halfWidth + barrierOffset) >%
          %< } >%
          ]
        }
      %< } >%
      %< if (leftBarrier) { >%
        CrashBarrier {
          name "left crash barrier"
          subdivision -1
          enableBoundingObject IS leftBarrierBoundingObject
          barrierOnRightSide TRUE
          path [
          %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
            %<= (halfWidth + barrierOffset) * Math.sin(angle[i]) + wayPoints[i].x >% %<= (halfWidth + barrierOffset) * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z + Math.sin(tilt[i]) * (halfWidth + barrierOffset) >%
          %< } >%
          ]
        }
      %< } >%
      # bottom
      %< if (bottom) { >%
        Shape {
          appearance PBRAppearance {
            baseColorMap ImageTexture {
              url IS bottomTexture
              filtering 5
            }
            roughness 0.8
            metalness 0
          }
          geometry DEF BOTTOM_GEOMETRY IndexedFaceSet {
            coord Coordinate {
              point [
                %<
                  let leftHeightOffset = 0.0;
                  let rightHeightOffset = 0.0;
                  if (leftBorder && nbBorderWidthPoint === 0 && borderHeight < 0)
                    leftHeightOffset = borderHeight;
                  if (rightBorder && nbBorderWidthPoint === 0 && borderHeight < 0)
                    rightHeightOffset = borderHeight;
                >%
                %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                  %< if (leftBorder && nbBorderWidthPoint > 0) { >%
                    %<= (halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= (halfWidth + borderWidth[i]) * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z + Math.sin(tilt[i]) * halfWidth >%
                  %< } else { >%
                    %<= halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<= halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z + Math.sin(tilt[i]) * halfWidth + leftHeightOffset >%
                  %< } >%
                  %< if (rightBorder && nbBorderWidthPoint > 0) { >%
                    %<= -(halfWidth + borderWidth[i]) * Math.sin(angle[i]) + wayPoints[i].x >% %<= -(halfWidth + borderWidth[i]) * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z - Math.sin(tilt[i]) * halfWidth >%
                  %< } else { >%
                    %<= -halfWidth * Math.sin(angle[i]) + wayPoints[i].x >% %<= -halfWidth * Math.cos(angle[i]) + wayPoints[i].y >% %<= wayPoints[i].z - Math.sin(tilt[i]) * halfWidth + rightHeightOffset >%
                  %< } >%
                %< } >%
              ]
            }
            %< if (useBottomTexture) { >%
              texCoord TextureCoordinate {
                point [
                  %< for (let i = 0; i <= nbWayPoint - 1; ++i) { >%
                    %<
                      let bottomWidth = width;
                      if (leftBorder && nbBorderWidthPoint > 0)
                        bottomWidth = bottomWidth + borderWidth[i];
                      if (rightBorder && nbBorderWidthPoint > 0)
                        bottomWidth = bottomWidth + borderWidth[i];
                    >%
                    %<= distance[i] >%     0
                    %<= distance[i] >% %<= bottomWidth >%
                  %< } >%
                ]
              }
            %< } >%
            coordIndex [
              %< let skip = 2; >%
              %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                %<= skip * i >% %<= skip * (i + 1) >% %<= 1 + skip * (i + 1) >% %<= 1 + skip * i >% -1
              %< } >%
            ]
            %< if (useBottomTexture) { >%
              texCoordIndex [
                %< skip = 2; >%
                %< for (let i = 0; i <= nbWayPoint - 2; ++i) { >%
                  %<= skip * i >% %<= skip * (i + 1) >% %<= 1 + skip * (i + 1) >% %<= 1 + skip * i >% -1
                %< } >%
              ]
            %< } >%
            creaseAngle 0.2
          }
          castShadows IS castShadows
        }
      %< } >%
      # turn lanes (forward)
      %< if (nbWayPoint > 2 && fields.turnLanesForward.value !== '') { >%
        Transform {
          translation %<= wayPoints[nbWayPoint-1].y >% %<= wayPoints[nbWayPoint-1].z + heightOffset >% %<= wayPoints[nbWayPoint-1].x >%
          rotation 0 1 0 %<= Math.PI - angle[nbWayPoint - 1] >%
          children [
          %<
            let turnLanes = fields.turnLanesForward.value.split('|');
            let nTurnLanes = turnLanes.length;
          >%
          %< for (let i = 0; i < nTurnLanes; ++i) { >%
            Transform {
              translation %<= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width >% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %<
                        let through = turnLanes[i].match('through');
                        let left = turnLanes[i].match('left');
                        let right = turnLanes[i].match('right');

                        let trX = 0;
                        if (left !== null)
                          trX = trX + 1;
                        if (right !== null)
                          trX = trX + 2;

                        let trY = through !== null ? 1 : 0;
                      >%
                      scale 0.25 0.5
                      translation %<= trX >% %<= trY >%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %< } >%
          ]
        }
      %< } >%
      # turn lanes (backward)
      %< if (nbWayPoint > 2 && fields.turnLanesBackward.value !== '') { >%
        Transform {
          translation %<= wayPoints[0].y >% %<= wayPoints[0].z + heightOffset >% %<= wayPoints[0].x >%
          rotation 0 1 0 %<= - angle[2] >%
          children [
          %<
            let turnLanes = fields.turnLanesBackward.value.split('|');
            let nTurnLanes = turnLanes.length;
          >%
          %< for (let i = 0; i < nTurnLanes; ++i) { >%
            Transform {
              translation %<= ((i - nTurnLanes - 1.0) / numberOfLanes + 0.5) * width >% 0 4
              children [
                Shape {
                  appearance PBRAppearance {
                    baseColorMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/painted_arrows.png"
                      ]
                      filtering 5
                    }
                    roughness 0.7
                    metalness 0
                    normalMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_normal.jpg"
                      ]
                      filtering 5
                    }
                    occlusionMap ImageTexture {
                      url [
                        "webots://projects/objects/road/protos/textures/line_occlusion.jpg"
                      ]
                      filtering 5
                    }
                    textureTransform TextureTransform {
                      %<
                        let through = turnLanes[i].match('through');
                        let left = turnLanes[i].match('left');
                        let right = turnLanes[i].match('right');

                        let trX = 0;
                        if (left !== null)
                          trX = trX + 1;
                        if (right !== null)
                          trX = trX + 2;

                        let trY = through !== null ? 1 : 0;
                      >%
                      scale 0.25 0.5
                      translation %<= trX >% %<= trY >%
                    }
                  }
                  geometry Plane {
                    size 1 4
                  }
                  castShadows FALSE
                }
              ]
            }
          %< } >%
          ]
        }
      %< } >%
    ]
    locked IS locked
  }
}
