#VRML_SIM R2022a utf8
# license: Copyright Cyberbotics Ltd. Licensed for use only with Webots.
# license url: https://cyberbotics.com/webots_assets_license
# This bounding object with a pipe shape is formed by a group of boxes.
# template language: javascript

PROTO PipeBoundingObject [
  field SFFloat    height          2       # Defines the height of the pipe.
  field SFFloat    radius          1       # Defines the radius of the pipe.
  field SFFloat    thickness       0.1     # Defines the thickness of the pipe.
  field SFInt32    subdivision     24      # Defines the number of polygons used to represent the pipe and so its resolution.
  field SFFloat    accuracy        0.0001  # Defines how much boxes position can differ on y axis: a 0 value represents an error-free model but it will slow down the simulation.
]
{
  %<
    import * as wbrandom from 'wbrandom.js';

    // parameter checking
    let subdivision = fields.subdivision.value;
    if (subdivision > 200)
      console.log('High value for \'subdivision\'. This can slow down the simulation');
    else if (subdivision < 8) {
      subdivision = 8;
      console.error('\'subdivision\' must be greater or equal to 8. Value reset to ' + subdivision + '.');
    }

    let height = fields.height.value;
    if (height <= 0) {
      height = fields.height.defaultValue;
      console.error('\'height\' must be strictly positive. Value reset to ' + height + '.');
    }

    let radius = fields.radius.value;
    if (radius <= 0) {
      radius = fields.radius.defaultValue;
      console.error('\'radius\' must be strictly positive. Value reset to ' + radius + '.');
    }

    let thickness = fields.thickness.value;
    if (thickness <= 0) {
      thickness = radius * 0.5;
      console.error('\'thickness\' must be greater than zero. Value reset to ' + thickness + '.');
    } else if (thickness >= fields.radius.value) {
      console.error('\'thickness\' must be smaller than \'radius\'.');
      thickness = radius * 0.5;
    }

    // global stuff before entering in the main loop
    const beta = 2.0 * Math.PI / subdivision;
    const alpha = beta * 0.5;
    const innerRadius = radius - thickness;
    const su = radius * Math.sin(alpha) * 2.0;
    let sv = radius * Math.cos(alpha) - innerRadius;
    if (sv < 0) {
      // fixed edge case:
      //   There are 2 inner radius, depending if we measure it along the center or along the edge of the boxes.
      //   If the thickness is below the difference of these two radius, then the algorithm can not achieve.
      sv = Math.abs(sv);
      console.error('Either \'thickness\' or \'subdivision\' are too small for the box subdivision algorithm. Value reset to ' + su + '.');
    }
    const sw = height;
    const boxRadius = innerRadius + sv * 0.5;
  >%
  Group { # set of boxes
    children [
      %<
          let gamma, ax, ay, az, angle, offset;
          for (let i = 0; i <= subdivision - 1; ++i) {
            // position of an internal box
            gamma = beta * i + beta * 0.5 + (subdivision % 2) * Math.PI / subdivision;
            ax = boxRadius * Math.cos(gamma);
            ay = boxRadius * Math.sin(gamma);
            az = 0;
            angle = gamma + 0.5 * Math.PI;
            // add small offset to boxes z translation to reduce constraints on the top and bottom face due to co-planarity
            offset = wbrandom.real(-1.0, 1.0) * fields.accuracy.value;
        >%
        Transform {
          translation %<= ax >% %<= ay >% %<= az + offset >%
          rotation 0 0 1 %<= angle >%
          children [
            Shape {
              appearance Appearance {
                material Material {
                }
              }
              geometry Box {
              size %<= su >% %<= sv >% %<= sw >%
            }
            }
          ]
        }
      %< } >%
    ]
  }
}
